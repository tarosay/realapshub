{"version":3,"file":"index-CSY3vuRK.js","sources":["../../node_modules/fflate/esm/browser.js","../../src/scripts/core/PFMLoader.ts","../../src/scripts/core/Image2d.ts","../../src/scripts/core/Point.ts","../../src/scripts/controls/Marker.ts","../../src/scripts/utilities/ImageNames.ts","../../src/scripts/controls/Scalebar.ts","../../src/scripts/controls/ImageSelector.ts","../../src/scripts/core/Rectangle.ts","../../src/scripts/controls/CanvasBase.ts","../../src/scripts/controls/BackCanvas.ts","../../src/scripts/controls/MarkerContainer.ts","../../src/scripts/controls/FrontCanvas.ts","../../src/scripts/controls/LumimapliteCanvas.ts","../../src/scripts/core/BitmapUtil.ts","../../src/scripts/core/Settings.ts","../../src/scripts/constants.ts","../../src/scripts/LumimapLite.ts","../../src/scripts/index.ts"],"sourcesContent":["// DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n// https://tools.ietf.org/html/rfc1951\n// You may also wish to take a look at the guide I made about this program:\n// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad\n// Some of the following code is similar to that of UZIP.js:\n// https://github.com/photopea/UZIP.js\n// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.\n// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint\n// is better for memory in most engines (I *think*).\nvar ch2 = {};\nvar wk = (function (c, id, msg, transfer, cb) {\n    var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([\n        c + ';addEventListener(\"error\",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'\n    ], { type: 'text/javascript' }))));\n    w.onmessage = function (e) {\n        var d = e.data, ed = d.$e$;\n        if (ed) {\n            var err = new Error(ed[0]);\n            err['code'] = ed[1];\n            err.stack = ed[2];\n            cb(err, null);\n        }\n        else\n            cb(null, d);\n    };\n    w.postMessage(msg, transfer);\n    return w;\n});\n\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;\n// fixed length extra bits\nvar fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);\n// fixed distance extra bits\nvar fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);\n// code length index map\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n// get base, reverse index map from extra bits\nvar freb = function (eb, start) {\n    var b = new u16(31);\n    for (var i = 0; i < 31; ++i) {\n        b[i] = start += 1 << eb[i - 1];\n    }\n    // numbers here are at max 18 bits\n    var r = new i32(b[30]);\n    for (var i = 1; i < 30; ++i) {\n        for (var j = b[i]; j < b[i + 1]; ++j) {\n            r[j] = ((j - b[i]) << 5) | i;\n        }\n    }\n    return { b: b, r: r };\n};\nvar _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b.b, revfd = _b.r;\n// map of value to reverse (assuming 16 bits)\nvar rev = new u16(32768);\nfor (var i = 0; i < 32768; ++i) {\n    // reverse table algorithm from SO\n    var x = ((i & 0xAAAA) >> 1) | ((i & 0x5555) << 1);\n    x = ((x & 0xCCCC) >> 2) | ((x & 0x3333) << 2);\n    x = ((x & 0xF0F0) >> 4) | ((x & 0x0F0F) << 4);\n    rev[i] = (((x & 0xFF00) >> 8) | ((x & 0x00FF) << 8)) >> 1;\n}\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nvar hMap = (function (cd, mb, r) {\n    var s = cd.length;\n    // index\n    var i = 0;\n    // u16 \"map\": index -> # of codes with bit length = index\n    var l = new u16(mb);\n    // length of cd must be 288 (total # of codes)\n    for (; i < s; ++i) {\n        if (cd[i])\n            ++l[cd[i] - 1];\n    }\n    // u16 \"map\": index -> minimum code for bit length = index\n    var le = new u16(mb);\n    for (i = 1; i < mb; ++i) {\n        le[i] = (le[i - 1] + l[i - 1]) << 1;\n    }\n    var co;\n    if (r) {\n        // u16 \"map\": index -> number of actual bits, symbol for code\n        co = new u16(1 << mb);\n        // bits to remove for reverser\n        var rvb = 15 - mb;\n        for (i = 0; i < s; ++i) {\n            // ignore 0 lengths\n            if (cd[i]) {\n                // num encoding both symbol and bits read\n                var sv = (i << 4) | cd[i];\n                // free bits\n                var r_1 = mb - cd[i];\n                // start value\n                var v = le[cd[i] - 1]++ << r_1;\n                // m is end value\n                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {\n                    // every 16 bit value starting with the code yields the same result\n                    co[rev[v] >> rvb] = sv;\n                }\n            }\n        }\n    }\n    else {\n        co = new u16(s);\n        for (i = 0; i < s; ++i) {\n            if (cd[i]) {\n                co[i] = rev[le[cd[i] - 1]++] >> (15 - cd[i]);\n            }\n        }\n    }\n    return co;\n});\n// fixed length tree\nvar flt = new u8(288);\nfor (var i = 0; i < 144; ++i)\n    flt[i] = 8;\nfor (var i = 144; i < 256; ++i)\n    flt[i] = 9;\nfor (var i = 256; i < 280; ++i)\n    flt[i] = 7;\nfor (var i = 280; i < 288; ++i)\n    flt[i] = 8;\n// fixed distance tree\nvar fdt = new u8(32);\nfor (var i = 0; i < 32; ++i)\n    fdt[i] = 5;\n// fixed length map\nvar flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);\n// fixed distance map\nvar fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\n// find max of array\nvar max = function (a) {\n    var m = a[0];\n    for (var i = 1; i < a.length; ++i) {\n        if (a[i] > m)\n            m = a[i];\n    }\n    return m;\n};\n// read d, starting at bit p and mask with m\nvar bits = function (d, p, m) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;\n};\n// read d, starting at bit p continuing for at least 16 bits\nvar bits16 = function (d, p) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));\n};\n// get end of byte\nvar shft = function (p) { return ((p + 7) / 8) | 0; };\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nvar slc = function (v, s, e) {\n    if (s == null || s < 0)\n        s = 0;\n    if (e == null || e > v.length)\n        e = v.length;\n    // can't use .constructor in case user-supplied\n    return new u8(v.subarray(s, e));\n};\n/**\n * Codes for errors generated within this library\n */\nexport var FlateErrorCode = {\n    UnexpectedEOF: 0,\n    InvalidBlockType: 1,\n    InvalidLengthLiteral: 2,\n    InvalidDistance: 3,\n    StreamFinished: 4,\n    NoStreamHandler: 5,\n    InvalidHeader: 6,\n    NoCallback: 7,\n    InvalidUTF8: 8,\n    ExtraFieldTooLong: 9,\n    InvalidDate: 10,\n    FilenameTooLong: 11,\n    StreamFinishing: 12,\n    InvalidZipData: 13,\n    UnknownCompressionMethod: 14\n};\n// error codes\nvar ec = [\n    'unexpected EOF',\n    'invalid block type',\n    'invalid length/literal',\n    'invalid distance',\n    'stream finished',\n    'no stream handler',\n    ,\n    'no callback',\n    'invalid UTF-8 data',\n    'extra field too long',\n    'date not in range 1980-2099',\n    'filename too long',\n    'stream finishing',\n    'invalid zip data'\n    // determined by unknown compression method\n];\n;\nvar err = function (ind, msg, nt) {\n    var e = new Error(msg || ec[ind]);\n    e.code = ind;\n    if (Error.captureStackTrace)\n        Error.captureStackTrace(e, err);\n    if (!nt)\n        throw e;\n    return e;\n};\n// expands raw DEFLATE data\nvar inflt = function (dat, st, buf, dict) {\n    // source length       dict length\n    var sl = dat.length, dl = dict ? dict.length : 0;\n    if (!sl || st.f && !st.l)\n        return buf || new u8(0);\n    var noBuf = !buf;\n    // have to estimate size\n    var resize = noBuf || st.i != 2;\n    // no state\n    var noSt = st.i;\n    // Assumes roughly 33% compression ratio average\n    if (noBuf)\n        buf = new u8(sl * 3);\n    // ensure buffer can fit at least l elements\n    var cbuf = function (l) {\n        var bl = buf.length;\n        // need to increase size to fit\n        if (l > bl) {\n            // Double or set to necessary, whichever is greater\n            var nbuf = new u8(Math.max(bl * 2, l));\n            nbuf.set(buf);\n            buf = nbuf;\n        }\n    };\n    //  last chunk         bitpos           bytes\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    // total bits\n    var tbts = sl * 8;\n    do {\n        if (!lm) {\n            // BFINAL - this is only 1 when last chunk is next\n            final = bits(dat, pos, 1);\n            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n            var type = bits(dat, pos + 1, 3);\n            pos += 3;\n            if (!type) {\n                // go to end of byte boundary\n                var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;\n                if (t > sl) {\n                    if (noSt)\n                        err(0);\n                    break;\n                }\n                // ensure size\n                if (resize)\n                    cbuf(bt + l);\n                // Copy over uncompressed data\n                buf.set(dat.subarray(s, t), bt);\n                // Get new bitpos, update byte count\n                st.b = bt += l, st.p = pos = t * 8, st.f = final;\n                continue;\n            }\n            else if (type == 1)\n                lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n            else if (type == 2) {\n                //  literal                            lengths\n                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n                var tl = hLit + bits(dat, pos + 5, 31) + 1;\n                pos += 14;\n                // length+distance tree\n                var ldt = new u8(tl);\n                // code length tree\n                var clt = new u8(19);\n                for (var i = 0; i < hcLen; ++i) {\n                    // use index map to get real code\n                    clt[clim[i]] = bits(dat, pos + i * 3, 7);\n                }\n                pos += hcLen * 3;\n                // code lengths bits\n                var clb = max(clt), clbmsk = (1 << clb) - 1;\n                // code lengths map\n                var clm = hMap(clt, clb, 1);\n                for (var i = 0; i < tl;) {\n                    var r = clm[bits(dat, pos, clbmsk)];\n                    // bits read\n                    pos += r & 15;\n                    // symbol\n                    var s = r >> 4;\n                    // code length to copy\n                    if (s < 16) {\n                        ldt[i++] = s;\n                    }\n                    else {\n                        //  copy   count\n                        var c = 0, n = 0;\n                        if (s == 16)\n                            n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n                        else if (s == 17)\n                            n = 3 + bits(dat, pos, 7), pos += 3;\n                        else if (s == 18)\n                            n = 11 + bits(dat, pos, 127), pos += 7;\n                        while (n--)\n                            ldt[i++] = c;\n                    }\n                }\n                //    length tree                 distance tree\n                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n                // max length bits\n                lbt = max(lt);\n                // max dist bits\n                dbt = max(dt);\n                lm = hMap(lt, lbt, 1);\n                dm = hMap(dt, dbt, 1);\n            }\n            else\n                err(1);\n            if (pos > tbts) {\n                if (noSt)\n                    err(0);\n                break;\n            }\n        }\n        // Make sure the buffer can hold this + the largest possible addition\n        // Maximum chunk size (practically, theoretically infinite) is 2^17\n        if (resize)\n            cbuf(bt + 131072);\n        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n        var lpos = pos;\n        for (;; lpos = pos) {\n            // bits read, code\n            var c = lm[bits16(dat, pos) & lms], sym = c >> 4;\n            pos += c & 15;\n            if (pos > tbts) {\n                if (noSt)\n                    err(0);\n                break;\n            }\n            if (!c)\n                err(2);\n            if (sym < 256)\n                buf[bt++] = sym;\n            else if (sym == 256) {\n                lpos = pos, lm = null;\n                break;\n            }\n            else {\n                var add = sym - 254;\n                // no extra bits needed if less\n                if (sym > 264) {\n                    // index\n                    var i = sym - 257, b = fleb[i];\n                    add = bits(dat, pos, (1 << b) - 1) + fl[i];\n                    pos += b;\n                }\n                // dist\n                var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;\n                if (!d)\n                    err(3);\n                pos += d & 15;\n                var dt = fd[dsym];\n                if (dsym > 3) {\n                    var b = fdeb[dsym];\n                    dt += bits16(dat, pos) & (1 << b) - 1, pos += b;\n                }\n                if (pos > tbts) {\n                    if (noSt)\n                        err(0);\n                    break;\n                }\n                if (resize)\n                    cbuf(bt + 131072);\n                var end = bt + add;\n                if (bt < dt) {\n                    var shift = dl - dt, dend = Math.min(dt, end);\n                    if (shift + bt < 0)\n                        err(3);\n                    for (; bt < dend; ++bt)\n                        buf[bt] = dict[shift + bt];\n                }\n                for (; bt < end; ++bt)\n                    buf[bt] = buf[bt - dt];\n            }\n        }\n        st.l = lm, st.p = lpos, st.b = bt, st.f = final;\n        if (lm)\n            final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    } while (!final);\n    // don't reallocate for streams or user buffers\n    return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);\n};\n// starting at p, write the minimum number of bits that can hold v to d\nvar wbits = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >> 8;\n};\n// starting at p, write the minimum number of bits (>8) that can hold v to d\nvar wbits16 = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >> 8;\n    d[o + 2] |= v >> 16;\n};\n// creates code lengths from a frequency table\nvar hTree = function (d, mb) {\n    // Need extra info to make a tree\n    var t = [];\n    for (var i = 0; i < d.length; ++i) {\n        if (d[i])\n            t.push({ s: i, f: d[i] });\n    }\n    var s = t.length;\n    var t2 = t.slice();\n    if (!s)\n        return { t: et, l: 0 };\n    if (s == 1) {\n        var v = new u8(t[0].s + 1);\n        v[t[0].s] = 1;\n        return { t: v, l: 1 };\n    }\n    t.sort(function (a, b) { return a.f - b.f; });\n    // after i2 reaches last ind, will be stopped\n    // freq must be greater than largest possible number of symbols\n    t.push({ s: -1, f: 25001 });\n    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;\n    t[0] = { s: -1, f: l.f + r.f, l: l, r: r };\n    // efficient algorithm from UZIP.js\n    // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n    // symbols that combined have high freq, will start processing i2 (high-freq,\n    // non-composite) symbols instead\n    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n    while (i1 != s - 1) {\n        l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n        t[i1++] = { s: -1, f: l.f + r.f, l: l, r: r };\n    }\n    var maxSym = t2[0].s;\n    for (var i = 1; i < s; ++i) {\n        if (t2[i].s > maxSym)\n            maxSym = t2[i].s;\n    }\n    // code lengths\n    var tr = new u16(maxSym + 1);\n    // max bits in tree\n    var mbt = ln(t[i1 - 1], tr, 0);\n    if (mbt > mb) {\n        // more algorithms from UZIP.js\n        // TODO: find out how this code works (debt)\n        //  ind    debt\n        var i = 0, dt = 0;\n        //    left            cost\n        var lft = mbt - mb, cst = 1 << lft;\n        t2.sort(function (a, b) { return tr[b.s] - tr[a.s] || a.f - b.f; });\n        for (; i < s; ++i) {\n            var i2_1 = t2[i].s;\n            if (tr[i2_1] > mb) {\n                dt += cst - (1 << (mbt - tr[i2_1]));\n                tr[i2_1] = mb;\n            }\n            else\n                break;\n        }\n        dt >>= lft;\n        while (dt > 0) {\n            var i2_2 = t2[i].s;\n            if (tr[i2_2] < mb)\n                dt -= 1 << (mb - tr[i2_2]++ - 1);\n            else\n                ++i;\n        }\n        for (; i >= 0 && dt; --i) {\n            var i2_3 = t2[i].s;\n            if (tr[i2_3] == mb) {\n                --tr[i2_3];\n                ++dt;\n            }\n        }\n        mbt = mb;\n    }\n    return { t: new u8(tr), l: mbt };\n};\n// get the max length and assign length codes\nvar ln = function (n, l, d) {\n    return n.s == -1\n        ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))\n        : (l[n.s] = d);\n};\n// length codes generation\nvar lc = function (c) {\n    var s = c.length;\n    // Note that the semicolon was intentional\n    while (s && !c[--s])\n        ;\n    var cl = new u16(++s);\n    //  ind      num         streak\n    var cli = 0, cln = c[0], cls = 1;\n    var w = function (v) { cl[cli++] = v; };\n    for (var i = 1; i <= s; ++i) {\n        if (c[i] == cln && i != s)\n            ++cls;\n        else {\n            if (!cln && cls > 2) {\n                for (; cls > 138; cls -= 138)\n                    w(32754);\n                if (cls > 2) {\n                    w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);\n                    cls = 0;\n                }\n            }\n            else if (cls > 3) {\n                w(cln), --cls;\n                for (; cls > 6; cls -= 6)\n                    w(8304);\n                if (cls > 2)\n                    w(((cls - 3) << 5) | 8208), cls = 0;\n            }\n            while (cls--)\n                w(cln);\n            cls = 1;\n            cln = c[i];\n        }\n    }\n    return { c: cl.subarray(0, cli), n: s };\n};\n// calculate the length of output from tree, code lengths\nvar clen = function (cf, cl) {\n    var l = 0;\n    for (var i = 0; i < cl.length; ++i)\n        l += cf[i] * cl[i];\n    return l;\n};\n// writes a fixed block\n// returns the new bit pos\nvar wfblk = function (out, pos, dat) {\n    // no need to write 00 as type: TypedArray defaults to 0\n    var s = dat.length;\n    var o = shft(pos + 2);\n    out[o] = s & 255;\n    out[o + 1] = s >> 8;\n    out[o + 2] = out[o] ^ 255;\n    out[o + 3] = out[o + 1] ^ 255;\n    for (var i = 0; i < s; ++i)\n        out[o + i + 4] = dat[i];\n    return (o + 4 + s) * 8;\n};\n// writes a block\nvar wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n    wbits(out, p++, final);\n    ++lf[256];\n    var _a = hTree(lf, 15), dlt = _a.t, mlb = _a.l;\n    var _b = hTree(df, 15), ddt = _b.t, mdb = _b.l;\n    var _c = lc(dlt), lclt = _c.c, nlc = _c.n;\n    var _d = lc(ddt), lcdt = _d.c, ndc = _d.n;\n    var lcfreq = new u16(19);\n    for (var i = 0; i < lclt.length; ++i)\n        ++lcfreq[lclt[i] & 31];\n    for (var i = 0; i < lcdt.length; ++i)\n        ++lcfreq[lcdt[i] & 31];\n    var _e = hTree(lcfreq, 7), lct = _e.t, mlcb = _e.l;\n    var nlcc = 19;\n    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)\n        ;\n    var flen = (bl + 5) << 3;\n    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];\n    if (bs >= 0 && flen <= ftlen && flen <= dtlen)\n        return wfblk(out, p, dat.subarray(bs, bs + bl));\n    var lm, ll, dm, dl;\n    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\n    if (dtlen < ftlen) {\n        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n        var llm = hMap(lct, mlcb, 0);\n        wbits(out, p, nlc - 257);\n        wbits(out, p + 5, ndc - 1);\n        wbits(out, p + 10, nlcc - 4);\n        p += 14;\n        for (var i = 0; i < nlcc; ++i)\n            wbits(out, p + 3 * i, lct[clim[i]]);\n        p += 3 * nlcc;\n        var lcts = [lclt, lcdt];\n        for (var it = 0; it < 2; ++it) {\n            var clct = lcts[it];\n            for (var i = 0; i < clct.length; ++i) {\n                var len = clct[i] & 31;\n                wbits(out, p, llm[len]), p += lct[len];\n                if (len > 15)\n                    wbits(out, p, (clct[i] >> 5) & 127), p += clct[i] >> 12;\n            }\n        }\n    }\n    else {\n        lm = flm, ll = flt, dm = fdm, dl = fdt;\n    }\n    for (var i = 0; i < li; ++i) {\n        var sym = syms[i];\n        if (sym > 255) {\n            var len = (sym >> 18) & 31;\n            wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n            if (len > 7)\n                wbits(out, p, (sym >> 23) & 31), p += fleb[len];\n            var dst = sym & 31;\n            wbits16(out, p, dm[dst]), p += dl[dst];\n            if (dst > 3)\n                wbits16(out, p, (sym >> 5) & 8191), p += fdeb[dst];\n        }\n        else {\n            wbits16(out, p, lm[sym]), p += ll[sym];\n        }\n    }\n    wbits16(out, p, lm[256]);\n    return p + ll[256];\n};\n// deflate options (nice << 13) | chain\nvar deo = /*#__PURE__*/ new i32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);\n// empty\nvar et = /*#__PURE__*/ new u8(0);\n// compresses data into a raw DEFLATE buffer\nvar dflt = function (dat, lvl, plvl, pre, post, st) {\n    var s = st.z || dat.length;\n    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);\n    // writing to this writes to the output buffer\n    var w = o.subarray(pre, o.length - post);\n    var lst = st.l;\n    var pos = (st.r || 0) & 7;\n    if (lvl) {\n        if (pos)\n            w[0] = st.r >> 3;\n        var opt = deo[lvl - 1];\n        var n = opt >> 13, c = opt & 8191;\n        var msk_1 = (1 << plvl) - 1;\n        //    prev 2-byte val map    curr 2-byte val map\n        var prev = st.p || new u16(32768), head = st.h || new u16(msk_1 + 1);\n        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;\n        var hsh = function (i) { return (dat[i] ^ (dat[i + 1] << bs1_1) ^ (dat[i + 2] << bs2_1)) & msk_1; };\n        // 24576 is an arbitrary number of maximum symbols per block\n        // 424 buffer for last block\n        var syms = new i32(25000);\n        // length/literal freq   distance freq\n        var lf = new u16(288), df = new u16(32);\n        //  l/lcnt  exbits  index          l/lind  waitdx          blkpos\n        var lc_1 = 0, eb = 0, i = st.i || 0, li = 0, wi = st.w || 0, bs = 0;\n        for (; i + 2 < s; ++i) {\n            // hash value\n            var hv = hsh(i);\n            // index mod 32768    previous index mod\n            var imod = i & 32767, pimod = head[hv];\n            prev[imod] = pimod;\n            head[hv] = imod;\n            // We always should modify head and prev, but only add symbols if\n            // this data is not yet processed (\"wait\" for wait index)\n            if (wi <= i) {\n                // bytes remaining\n                var rem = s - i;\n                if ((lc_1 > 7000 || li > 24576) && (rem > 423 || !lst)) {\n                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n                    li = lc_1 = eb = 0, bs = i;\n                    for (var j = 0; j < 286; ++j)\n                        lf[j] = 0;\n                    for (var j = 0; j < 30; ++j)\n                        df[j] = 0;\n                }\n                //  len    dist   chain\n                var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;\n                if (rem > 2 && hv == hsh(i - dif)) {\n                    var maxn = Math.min(n, rem) - 1;\n                    var maxd = Math.min(32767, i);\n                    // max possible length\n                    // not capped at dif because decompressors implement \"rolling\" index population\n                    var ml = Math.min(258, rem);\n                    while (dif <= maxd && --ch_1 && imod != pimod) {\n                        if (dat[i + l] == dat[i + l - dif]) {\n                            var nl = 0;\n                            for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)\n                                ;\n                            if (nl > l) {\n                                l = nl, d = dif;\n                                // break out early when we reach \"nice\" (we are satisfied enough)\n                                if (nl > maxn)\n                                    break;\n                                // now, find the rarest 2-byte sequence within this\n                                // length of literals and search for that instead.\n                                // Much faster than just using the start\n                                var mmd = Math.min(dif, nl - 2);\n                                var md = 0;\n                                for (var j = 0; j < mmd; ++j) {\n                                    var ti = i - dif + j & 32767;\n                                    var pti = prev[ti];\n                                    var cd = ti - pti & 32767;\n                                    if (cd > md)\n                                        md = cd, pimod = ti;\n                                }\n                            }\n                        }\n                        // check the previous match\n                        imod = pimod, pimod = prev[imod];\n                        dif += imod - pimod & 32767;\n                    }\n                }\n                // d will be nonzero only when a match was found\n                if (d) {\n                    // store both dist and len data in one int32\n                    // Make sure this is recognized as a len/dist with 28th bit (2^28)\n                    syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];\n                    var lin = revfl[l] & 31, din = revfd[d] & 31;\n                    eb += fleb[lin] + fdeb[din];\n                    ++lf[257 + lin];\n                    ++df[din];\n                    wi = i + l;\n                    ++lc_1;\n                }\n                else {\n                    syms[li++] = dat[i];\n                    ++lf[dat[i]];\n                }\n            }\n        }\n        for (i = Math.max(i, wi); i < s; ++i) {\n            syms[li++] = dat[i];\n            ++lf[dat[i]];\n        }\n        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\n        if (!lst) {\n            st.r = (pos & 7) | w[(pos / 8) | 0] << 3;\n            // shft(pos) now 1 less if pos & 7 != 0\n            pos -= 7;\n            st.h = head, st.p = prev, st.i = i, st.w = wi;\n        }\n    }\n    else {\n        for (var i = st.w || 0; i < s + lst; i += 65535) {\n            // end\n            var e = i + 65535;\n            if (e >= s) {\n                // write final block\n                w[(pos / 8) | 0] = lst;\n                e = s;\n            }\n            pos = wfblk(w, pos + 1, dat.subarray(i, e));\n        }\n        st.i = s;\n    }\n    return slc(o, 0, pre + shft(pos) + post);\n};\n// CRC32 table\nvar crct = /*#__PURE__*/ (function () {\n    var t = new Int32Array(256);\n    for (var i = 0; i < 256; ++i) {\n        var c = i, k = 9;\n        while (--k)\n            c = ((c & 1) && -306674912) ^ (c >>> 1);\n        t[i] = c;\n    }\n    return t;\n})();\n// CRC32\nvar crc = function () {\n    var c = -1;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var cr = c;\n            for (var i = 0; i < d.length; ++i)\n                cr = crct[(cr & 255) ^ d[i]] ^ (cr >>> 8);\n            c = cr;\n        },\n        d: function () { return ~c; }\n    };\n};\n// Adler32\nvar adler = function () {\n    var a = 1, b = 0;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var n = a, m = b;\n            var l = d.length | 0;\n            for (var i = 0; i != l;) {\n                var e = Math.min(i + 2655, l);\n                for (; i < e; ++i)\n                    m += n += d[i];\n                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);\n            }\n            a = n, b = m;\n        },\n        d: function () {\n            a %= 65521, b %= 65521;\n            return (a & 255) << 24 | (a & 0xFF00) << 8 | (b & 255) << 8 | (b >> 8);\n        }\n    };\n};\n;\n// deflate with opts\nvar dopt = function (dat, opt, pre, post, st) {\n    if (!st) {\n        st = { l: 1 };\n        if (opt.dictionary) {\n            var dict = opt.dictionary.subarray(-32768);\n            var newDat = new u8(dict.length + dat.length);\n            newDat.set(dict);\n            newDat.set(dat, dict.length);\n            dat = newDat;\n            st.w = dict.length;\n        }\n    }\n    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? (st.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20) : (12 + opt.mem), pre, post, st);\n};\n// Walmart object spread\nvar mrg = function (a, b) {\n    var o = {};\n    for (var k in a)\n        o[k] = a[k];\n    for (var k in b)\n        o[k] = b[k];\n    return o;\n};\n// worker clone\n// This is possibly the craziest part of the entire codebase, despite how simple it may seem.\n// The only parameter to this function is a closure that returns an array of variables outside of the function scope.\n// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.\n// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).\n// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.\n// This took me three weeks to figure out how to do.\nvar wcln = function (fn, fnStr, td) {\n    var dt = fn();\n    var st = fn.toString();\n    var ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/\\s+/g, '').split(',');\n    for (var i = 0; i < dt.length; ++i) {\n        var v = dt[i], k = ks[i];\n        if (typeof v == 'function') {\n            fnStr += ';' + k + '=';\n            var st_1 = v.toString();\n            if (v.prototype) {\n                // for global objects\n                if (st_1.indexOf('[native code]') != -1) {\n                    var spInd = st_1.indexOf(' ', 8) + 1;\n                    fnStr += st_1.slice(spInd, st_1.indexOf('(', spInd));\n                }\n                else {\n                    fnStr += st_1;\n                    for (var t in v.prototype)\n                        fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString();\n                }\n            }\n            else\n                fnStr += st_1;\n        }\n        else\n            td[k] = v;\n    }\n    return fnStr;\n};\nvar ch = [];\n// clone bufs\nvar cbfs = function (v) {\n    var tl = [];\n    for (var k in v) {\n        if (v[k].buffer) {\n            tl.push((v[k] = new v[k].constructor(v[k])).buffer);\n        }\n    }\n    return tl;\n};\n// use a worker to execute code\nvar wrkr = function (fns, init, id, cb) {\n    if (!ch[id]) {\n        var fnStr = '', td_1 = {}, m = fns.length - 1;\n        for (var i = 0; i < m; ++i)\n            fnStr = wcln(fns[i], fnStr, td_1);\n        ch[id] = { c: wcln(fns[m], fnStr, td_1), e: td_1 };\n    }\n    var td = mrg({}, ch[id].e);\n    return wk(ch[id].c + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString() + '}', id, td, cbfs(td), cb);\n};\n// base async inflate fn\nvar bInflt = function () { return [u8, u16, i32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gopt]; };\nvar bDflt = function () { return [u8, u16, i32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf]; };\n// gzip extra\nvar gze = function () { return [gzh, gzhl, wbytes, crc, crct]; };\n// gunzip extra\nvar guze = function () { return [gzs, gzl]; };\n// zlib extra\nvar zle = function () { return [zlh, wbytes, adler]; };\n// unzlib extra\nvar zule = function () { return [zls]; };\n// post buf\nvar pbf = function (msg) { return postMessage(msg, [msg.buffer]); };\n// get opts\nvar gopt = function (o) { return o && {\n    out: o.size && new u8(o.size),\n    dictionary: o.dictionary\n}; };\n// async helper\nvar cbify = function (dat, opts, fns, init, id, cb) {\n    var w = wrkr(fns, init, id, function (err, dat) {\n        w.terminate();\n        cb(err, dat);\n    });\n    w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);\n    return function () { w.terminate(); };\n};\n// auto stream\nvar astrm = function (strm) {\n    strm.ondata = function (dat, final) { return postMessage([dat, final], [dat.buffer]); };\n    return function (ev) {\n        if (ev.data.length) {\n            strm.push(ev.data[0], ev.data[1]);\n            postMessage([ev.data[0].length]);\n        }\n        else\n            strm.flush();\n    };\n};\n// async stream attach\nvar astrmify = function (fns, strm, opts, init, id, flush, ext) {\n    var t;\n    var w = wrkr(fns, init, id, function (err, dat) {\n        if (err)\n            w.terminate(), strm.ondata.call(strm, err);\n        else if (!Array.isArray(dat))\n            ext(dat);\n        else if (dat.length == 1) {\n            strm.queuedSize -= dat[0];\n            if (strm.ondrain)\n                strm.ondrain(dat[0]);\n        }\n        else {\n            if (dat[1])\n                w.terminate();\n            strm.ondata.call(strm, err, dat[0], dat[1]);\n        }\n    });\n    w.postMessage(opts);\n    strm.queuedSize = 0;\n    strm.push = function (d, f) {\n        if (!strm.ondata)\n            err(5);\n        if (t)\n            strm.ondata(err(4, 0, 1), null, !!f);\n        strm.queuedSize += d.length;\n        w.postMessage([d, t = f], [d.buffer]);\n    };\n    strm.terminate = function () { w.terminate(); };\n    if (flush) {\n        strm.flush = function () { w.postMessage([]); };\n    }\n};\n// read 2 bytes\nvar b2 = function (d, b) { return d[b] | (d[b + 1] << 8); };\n// read 4 bytes\nvar b4 = function (d, b) { return (d[b] | (d[b + 1] << 8) | (d[b + 2] << 16) | (d[b + 3] << 24)) >>> 0; };\nvar b8 = function (d, b) { return b4(d, b) + (b4(d, b + 4) * 4294967296); };\n// write bytes\nvar wbytes = function (d, b, v) {\n    for (; v; ++b)\n        d[b] = v, v >>>= 8;\n};\n// gzip header\nvar gzh = function (c, o) {\n    var fn = o.filename;\n    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix\n    if (o.mtime != 0)\n        wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));\n    if (fn) {\n        c[3] = 8;\n        for (var i = 0; i <= fn.length; ++i)\n            c[i + 10] = fn.charCodeAt(i);\n    }\n};\n// gzip footer: -8 to -4 = CRC, -4 to -0 is length\n// gzip start\nvar gzs = function (d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n        err(6, 'invalid gzip data');\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4)\n        st += (d[10] | d[11] << 8) + 2;\n    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\n        ;\n    return st + (flg & 2);\n};\n// gzip length\nvar gzl = function (d) {\n    var l = d.length;\n    return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;\n};\n// gzip header length\nvar gzhl = function (o) { return 10 + (o.filename ? o.filename.length + 1 : 0); };\n// zlib header\nvar zlh = function (c, o) {\n    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n    c[0] = 120, c[1] = (fl << 6) | (o.dictionary && 32);\n    c[1] |= 31 - ((c[0] << 8) | c[1]) % 31;\n    if (o.dictionary) {\n        var h = adler();\n        h.p(o.dictionary);\n        wbytes(c, 2, h.d());\n    }\n};\n// zlib start\nvar zls = function (d, dict) {\n    if ((d[0] & 15) != 8 || (d[0] >> 4) > 7 || ((d[0] << 8 | d[1]) % 31))\n        err(6, 'invalid zlib data');\n    if ((d[1] >> 5 & 1) == +!dict)\n        err(6, 'invalid zlib data: ' + (d[1] & 32 ? 'need' : 'unexpected') + ' dictionary');\n    return (d[1] >> 3 & 4) + 2;\n};\nfunction StrmOpt(opts, cb) {\n    if (typeof opts == 'function')\n        cb = opts, opts = {};\n    this.ondata = cb;\n    return opts;\n}\n/**\n * Streaming DEFLATE compression\n */\nvar Deflate = /*#__PURE__*/ (function () {\n    function Deflate(opts, cb) {\n        if (typeof opts == 'function')\n            cb = opts, opts = {};\n        this.ondata = cb;\n        this.o = opts || {};\n        this.s = { l: 0, i: 32768, w: 32768, z: 32768 };\n        // Buffer length must always be 0 mod 32768 for index calculations to be correct when modifying head and prev\n        // 98304 = 32768 (lookback) + 65536 (common chunk size)\n        this.b = new u8(98304);\n        if (this.o.dictionary) {\n            var dict = this.o.dictionary.subarray(-32768);\n            this.b.set(dict, 32768 - dict.length);\n            this.s.i = 32768 - dict.length;\n        }\n    }\n    Deflate.prototype.p = function (c, f) {\n        this.ondata(dopt(c, this.o, 0, 0, this.s), f);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Deflate.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (this.s.l)\n            err(4);\n        var endLen = chunk.length + this.s.z;\n        if (endLen > this.b.length) {\n            if (endLen > 2 * this.b.length - 32768) {\n                var newBuf = new u8(endLen & -32768);\n                newBuf.set(this.b.subarray(0, this.s.z));\n                this.b = newBuf;\n            }\n            var split = this.b.length - this.s.z;\n            this.b.set(chunk.subarray(0, split), this.s.z);\n            this.s.z = this.b.length;\n            this.p(this.b, false);\n            this.b.set(this.b.subarray(-32768));\n            this.b.set(chunk.subarray(split), 32768);\n            this.s.z = chunk.length - split + 32768;\n            this.s.i = 32766, this.s.w = 32768;\n        }\n        else {\n            this.b.set(chunk, this.s.z);\n            this.s.z += chunk.length;\n        }\n        this.s.l = final & 1;\n        if (this.s.z > this.s.w + 8191 || final) {\n            this.p(this.b, final || false);\n            this.s.w = this.s.i, this.s.i -= 2;\n        }\n    };\n    /**\n     * Flushes buffered uncompressed data. Useful to immediately retrieve the\n     * deflated output for small inputs.\n     */\n    Deflate.prototype.flush = function () {\n        if (!this.ondata)\n            err(5);\n        if (this.s.l)\n            err(4);\n        this.p(this.b, false);\n        this.s.w = this.s.i, this.s.i -= 2;\n    };\n    return Deflate;\n}());\nexport { Deflate };\n/**\n * Asynchronous streaming DEFLATE compression\n */\nvar AsyncDeflate = /*#__PURE__*/ (function () {\n    function AsyncDeflate(opts, cb) {\n        astrmify([\n            bDflt,\n            function () { return [astrm, Deflate]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Deflate(ev.data);\n            onmessage = astrm(strm);\n        }, 6, 1);\n    }\n    return AsyncDeflate;\n}());\nexport { AsyncDeflate };\nexport function deflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n    ], function (ev) { return pbf(deflateSync(ev.data[0], ev.data[1])); }, 0, cb);\n}\n/**\n * Compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @returns The deflated version of the data\n */\nexport function deflateSync(data, opts) {\n    return dopt(data, opts || {}, 0, 0);\n}\n/**\n * Streaming DEFLATE decompression\n */\nvar Inflate = /*#__PURE__*/ (function () {\n    function Inflate(opts, cb) {\n        // no StrmOpt here to avoid adding to workerizer\n        if (typeof opts == 'function')\n            cb = opts, opts = {};\n        this.ondata = cb;\n        var dict = opts && opts.dictionary && opts.dictionary.subarray(-32768);\n        this.s = { i: 0, b: dict ? dict.length : 0 };\n        this.o = new u8(32768);\n        this.p = new u8(0);\n        if (dict)\n            this.o.set(dict);\n    }\n    Inflate.prototype.e = function (c) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        if (!this.p.length)\n            this.p = c;\n        else if (c.length) {\n            var n = new u8(this.p.length + c.length);\n            n.set(this.p), n.set(c, this.p.length), this.p = n;\n        }\n    };\n    Inflate.prototype.c = function (final) {\n        this.s.i = +(this.d = final || false);\n        var bts = this.s.b;\n        var dt = inflt(this.p, this.s, this.o);\n        this.ondata(slc(dt, bts, this.s.b), this.d);\n        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n        this.p = slc(this.p, (this.s.p / 8) | 0), this.s.p &= 7;\n    };\n    /**\n     * Pushes a chunk to be inflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the final chunk\n     */\n    Inflate.prototype.push = function (chunk, final) {\n        this.e(chunk), this.c(final);\n    };\n    return Inflate;\n}());\nexport { Inflate };\n/**\n * Asynchronous streaming DEFLATE decompression\n */\nvar AsyncInflate = /*#__PURE__*/ (function () {\n    function AsyncInflate(opts, cb) {\n        astrmify([\n            bInflt,\n            function () { return [astrm, Inflate]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Inflate(ev.data);\n            onmessage = astrm(strm);\n        }, 7, 0);\n    }\n    return AsyncInflate;\n}());\nexport { AsyncInflate };\nexport function inflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt\n    ], function (ev) { return pbf(inflateSync(ev.data[0], gopt(ev.data[1]))); }, 1, cb);\n}\n/**\n * Expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */\nexport function inflateSync(data, opts) {\n    return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);\n}\n// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.\n/**\n * Streaming GZIP compression\n */\nvar Gzip = /*#__PURE__*/ (function () {\n    function Gzip(opts, cb) {\n        this.c = crc();\n        this.l = 0;\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gzip.prototype.push = function (chunk, final) {\n        this.c.p(chunk);\n        this.l += chunk.length;\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Gzip.prototype.p = function (c, f) {\n        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, this.s);\n        if (this.v)\n            gzh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);\n        this.ondata(raw, f);\n    };\n    /**\n     * Flushes buffered uncompressed data. Useful to immediately retrieve the\n     * GZIPped output for small inputs.\n     */\n    Gzip.prototype.flush = function () {\n        Deflate.prototype.flush.call(this);\n    };\n    return Gzip;\n}());\nexport { Gzip };\n/**\n * Asynchronous streaming GZIP compression\n */\nvar AsyncGzip = /*#__PURE__*/ (function () {\n    function AsyncGzip(opts, cb) {\n        astrmify([\n            bDflt,\n            gze,\n            function () { return [astrm, Deflate, Gzip]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Gzip(ev.data);\n            onmessage = astrm(strm);\n        }, 8, 1);\n    }\n    return AsyncGzip;\n}());\nexport { AsyncGzip };\nexport function gzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n        gze,\n        function () { return [gzipSync]; }\n    ], function (ev) { return pbf(gzipSync(ev.data[0], ev.data[1])); }, 2, cb);\n}\n/**\n * Compresses data with GZIP\n * @param data The data to compress\n * @param opts The compression options\n * @returns The gzipped version of the data\n */\nexport function gzipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var c = crc(), l = data.length;\n    c.p(data);\n    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;\n    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;\n}\n/**\n * Streaming single or multi-member GZIP decompression\n */\nvar Gunzip = /*#__PURE__*/ (function () {\n    function Gunzip(opts, cb) {\n        this.v = 1;\n        this.r = 0;\n        Inflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GUNZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gunzip.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        this.r += chunk.length;\n        if (this.v) {\n            var p = this.p.subarray(this.v - 1);\n            var s = p.length > 3 ? gzs(p) : 4;\n            if (s > p.length) {\n                if (!final)\n                    return;\n            }\n            else if (this.v > 1 && this.onmember) {\n                this.onmember(this.r - p.length);\n            }\n            this.p = p.subarray(s), this.v = 0;\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n        // process concatenated GZIP\n        if (this.s.f && !this.s.l && !final) {\n            this.v = shft(this.s.p) + 9;\n            this.s = { i: 0 };\n            this.o = new u8(0);\n            this.push(new u8(0), final);\n        }\n    };\n    return Gunzip;\n}());\nexport { Gunzip };\n/**\n * Asynchronous streaming single or multi-member GZIP decompression\n */\nvar AsyncGunzip = /*#__PURE__*/ (function () {\n    function AsyncGunzip(opts, cb) {\n        var _this = this;\n        astrmify([\n            bInflt,\n            guze,\n            function () { return [astrm, Inflate, Gunzip]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Gunzip(ev.data);\n            strm.onmember = function (offset) { return postMessage(offset); };\n            onmessage = astrm(strm);\n        }, 9, 0, function (offset) { return _this.onmember && _this.onmember(offset); });\n    }\n    return AsyncGunzip;\n}());\nexport { AsyncGunzip };\nexport function gunzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt,\n        guze,\n        function () { return [gunzipSync]; }\n    ], function (ev) { return pbf(gunzipSync(ev.data[0], ev.data[1])); }, 3, cb);\n}\n/**\n * Expands GZIP data\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */\nexport function gunzipSync(data, opts) {\n    var st = gzs(data);\n    if (st + 8 > data.length)\n        err(6, 'invalid gzip data');\n    return inflt(data.subarray(st, -8), { i: 2 }, opts && opts.out || new u8(gzl(data)), opts && opts.dictionary);\n}\n/**\n * Streaming Zlib compression\n */\nvar Zlib = /*#__PURE__*/ (function () {\n    function Zlib(opts, cb) {\n        this.c = adler();\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be zlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Zlib.prototype.push = function (chunk, final) {\n        this.c.p(chunk);\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Zlib.prototype.p = function (c, f) {\n        var raw = dopt(c, this.o, this.v && (this.o.dictionary ? 6 : 2), f && 4, this.s);\n        if (this.v)\n            zlh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 4, this.c.d());\n        this.ondata(raw, f);\n    };\n    /**\n     * Flushes buffered uncompressed data. Useful to immediately retrieve the\n     * zlibbed output for small inputs.\n     */\n    Zlib.prototype.flush = function () {\n        Deflate.prototype.flush.call(this);\n    };\n    return Zlib;\n}());\nexport { Zlib };\n/**\n * Asynchronous streaming Zlib compression\n */\nvar AsyncZlib = /*#__PURE__*/ (function () {\n    function AsyncZlib(opts, cb) {\n        astrmify([\n            bDflt,\n            zle,\n            function () { return [astrm, Deflate, Zlib]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Zlib(ev.data);\n            onmessage = astrm(strm);\n        }, 10, 1);\n    }\n    return AsyncZlib;\n}());\nexport { AsyncZlib };\nexport function zlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n        zle,\n        function () { return [zlibSync]; }\n    ], function (ev) { return pbf(zlibSync(ev.data[0], ev.data[1])); }, 4, cb);\n}\n/**\n * Compress data with Zlib\n * @param data The data to compress\n * @param opts The compression options\n * @returns The zlib-compressed version of the data\n */\nexport function zlibSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var a = adler();\n    a.p(data);\n    var d = dopt(data, opts, opts.dictionary ? 6 : 2, 4);\n    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;\n}\n/**\n * Streaming Zlib decompression\n */\nvar Unzlib = /*#__PURE__*/ (function () {\n    function Unzlib(opts, cb) {\n        Inflate.call(this, opts, cb);\n        this.v = opts && opts.dictionary ? 2 : 1;\n    }\n    /**\n     * Pushes a chunk to be unzlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzlib.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            if (this.p.length < 6 && !final)\n                return;\n            this.p = this.p.subarray(zls(this.p, this.v - 1)), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 4)\n                err(6, 'invalid zlib data');\n            this.p = this.p.subarray(0, -4);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Unzlib;\n}());\nexport { Unzlib };\n/**\n * Asynchronous streaming Zlib decompression\n */\nvar AsyncUnzlib = /*#__PURE__*/ (function () {\n    function AsyncUnzlib(opts, cb) {\n        astrmify([\n            bInflt,\n            zule,\n            function () { return [astrm, Inflate, Unzlib]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Unzlib(ev.data);\n            onmessage = astrm(strm);\n        }, 11, 0);\n    }\n    return AsyncUnzlib;\n}());\nexport { AsyncUnzlib };\nexport function unzlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt,\n        zule,\n        function () { return [unzlibSync]; }\n    ], function (ev) { return pbf(unzlibSync(ev.data[0], gopt(ev.data[1]))); }, 5, cb);\n}\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */\nexport function unzlibSync(data, opts) {\n    return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), { i: 2 }, opts && opts.out, opts && opts.dictionary);\n}\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzip as compress, AsyncGzip as AsyncCompress };\nexport { gzipSync as compressSync, Gzip as Compress };\n/**\n * Streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar Decompress = /*#__PURE__*/ (function () {\n    function Decompress(opts, cb) {\n        this.o = StrmOpt.call(this, opts, cb) || {};\n        this.G = Gunzip;\n        this.I = Inflate;\n        this.Z = Unzlib;\n    }\n    // init substream\n    // overriden by AsyncDecompress\n    Decompress.prototype.i = function () {\n        var _this = this;\n        this.s.ondata = function (dat, final) {\n            _this.ondata(dat, final);\n        };\n    };\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Decompress.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (!this.s) {\n            if (this.p && this.p.length) {\n                var n = new u8(this.p.length + chunk.length);\n                n.set(this.p), n.set(chunk, this.p.length);\n            }\n            else\n                this.p = chunk;\n            if (this.p.length > 2) {\n                this.s = (this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8)\n                    ? new this.G(this.o)\n                    : ((this.p[0] & 15) != 8 || (this.p[0] >> 4) > 7 || ((this.p[0] << 8 | this.p[1]) % 31))\n                        ? new this.I(this.o)\n                        : new this.Z(this.o);\n                this.i();\n                this.s.push(this.p, final);\n                this.p = null;\n            }\n        }\n        else\n            this.s.push(chunk, final);\n    };\n    return Decompress;\n}());\nexport { Decompress };\n/**\n * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar AsyncDecompress = /*#__PURE__*/ (function () {\n    function AsyncDecompress(opts, cb) {\n        Decompress.call(this, opts, cb);\n        this.queuedSize = 0;\n        this.G = AsyncGunzip;\n        this.I = AsyncInflate;\n        this.Z = AsyncUnzlib;\n    }\n    AsyncDecompress.prototype.i = function () {\n        var _this = this;\n        this.s.ondata = function (err, dat, final) {\n            _this.ondata(err, dat, final);\n        };\n        this.s.ondrain = function (size) {\n            _this.queuedSize -= size;\n            if (_this.ondrain)\n                _this.ondrain(size);\n        };\n    };\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncDecompress.prototype.push = function (chunk, final) {\n        this.queuedSize += chunk.length;\n        Decompress.prototype.push.call(this, chunk, final);\n    };\n    return AsyncDecompress;\n}());\nexport { AsyncDecompress };\nexport function decompress(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzip(data, opts, cb)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflate(data, opts, cb)\n            : unzlib(data, opts, cb);\n}\n/**\n * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */\nexport function decompressSync(data, opts) {\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzipSync(data, opts)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflateSync(data, opts)\n            : unzlibSync(data, opts);\n}\n// flatten a directory structure\nvar fltn = function (d, p, t, o) {\n    for (var k in d) {\n        var val = d[k], n = p + k, op = o;\n        if (Array.isArray(val))\n            op = mrg(o, val[1]), val = val[0];\n        if (val instanceof u8)\n            t[n] = [val, op];\n        else {\n            t[n += '/'] = [new u8(0), op];\n            fltn(val, n, t, o);\n        }\n    }\n};\n// text encoder\nvar te = typeof TextEncoder != 'undefined' && /*#__PURE__*/ new TextEncoder();\n// text decoder\nvar td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();\n// text decoder stream\nvar tds = 0;\ntry {\n    td.decode(et, { stream: true });\n    tds = 1;\n}\ncatch (e) { }\n// decode UTF8\nvar dutf8 = function (d) {\n    for (var r = '', i = 0;;) {\n        var c = d[i++];\n        var eb = (c > 127) + (c > 223) + (c > 239);\n        if (i + eb > d.length)\n            return { s: r, r: slc(d, i - 1) };\n        if (!eb)\n            r += String.fromCharCode(c);\n        else if (eb == 3) {\n            c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63)) - 65536,\n                r += String.fromCharCode(55296 | (c >> 10), 56320 | (c & 1023));\n        }\n        else if (eb & 1)\n            r += String.fromCharCode((c & 31) << 6 | (d[i++] & 63));\n        else\n            r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63));\n    }\n};\n/**\n * Streaming UTF-8 decoding\n */\nvar DecodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is decoded\n     */\n    function DecodeUTF8(cb) {\n        this.ondata = cb;\n        if (tds)\n            this.t = new TextDecoder();\n        else\n            this.p = et;\n    }\n    /**\n     * Pushes a chunk to be decoded from UTF-8 binary\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    DecodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        final = !!final;\n        if (this.t) {\n            this.ondata(this.t.decode(chunk, { stream: true }), final);\n            if (final) {\n                if (this.t.decode().length)\n                    err(8);\n                this.t = null;\n            }\n            return;\n        }\n        if (!this.p)\n            err(4);\n        var dat = new u8(this.p.length + chunk.length);\n        dat.set(this.p);\n        dat.set(chunk, this.p.length);\n        var _a = dutf8(dat), s = _a.s, r = _a.r;\n        if (final) {\n            if (r.length)\n                err(8);\n            this.p = null;\n        }\n        else\n            this.p = r;\n        this.ondata(s, final);\n    };\n    return DecodeUTF8;\n}());\nexport { DecodeUTF8 };\n/**\n * Streaming UTF-8 encoding\n */\nvar EncodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is encoded\n     */\n    function EncodeUTF8(cb) {\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be encoded to UTF-8\n     * @param chunk The string data to push\n     * @param final Whether this is the last chunk\n     */\n    EncodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        this.ondata(strToU8(chunk), this.d = final || false);\n    };\n    return EncodeUTF8;\n}());\nexport { EncodeUTF8 };\n/**\n * Converts a string into a Uint8Array for use with compression/decompression methods\n * @param str The string to encode\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless decoding a binary string.\n * @returns The string encoded in UTF-8/Latin-1 binary\n */\nexport function strToU8(str, latin1) {\n    if (latin1) {\n        var ar_1 = new u8(str.length);\n        for (var i = 0; i < str.length; ++i)\n            ar_1[i] = str.charCodeAt(i);\n        return ar_1;\n    }\n    if (te)\n        return te.encode(str);\n    var l = str.length;\n    var ar = new u8(str.length + (str.length >> 1));\n    var ai = 0;\n    var w = function (v) { ar[ai++] = v; };\n    for (var i = 0; i < l; ++i) {\n        if (ai + 5 > ar.length) {\n            var n = new u8(ai + 8 + ((l - i) << 1));\n            n.set(ar);\n            ar = n;\n        }\n        var c = str.charCodeAt(i);\n        if (c < 128 || latin1)\n            w(c);\n        else if (c < 2048)\n            w(192 | (c >> 6)), w(128 | (c & 63));\n        else if (c > 55295 && c < 57344)\n            c = 65536 + (c & 1023 << 10) | (str.charCodeAt(++i) & 1023),\n                w(240 | (c >> 18)), w(128 | ((c >> 12) & 63)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n        else\n            w(224 | (c >> 12)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n    }\n    return slc(ar, 0, ai);\n}\n/**\n * Converts a Uint8Array to a string\n * @param dat The data to decode to string\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless encoding to binary string.\n * @returns The original UTF-8/Latin-1 string\n */\nexport function strFromU8(dat, latin1) {\n    if (latin1) {\n        var r = '';\n        for (var i = 0; i < dat.length; i += 16384)\n            r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));\n        return r;\n    }\n    else if (td) {\n        return td.decode(dat);\n    }\n    else {\n        var _a = dutf8(dat), s = _a.s, r = _a.r;\n        if (r.length)\n            err(8);\n        return s;\n    }\n}\n;\n// deflate bit flag\nvar dbf = function (l) { return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0; };\n// skip local zip header\nvar slzh = function (d, b) { return b + 30 + b2(d, b + 26) + b2(d, b + 28); };\n// read zip header\nvar zh = function (d, b, z) {\n    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n    var _a = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a[0], su = _a[1], off = _a[2];\n    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];\n};\n// read zip64 extra field\nvar z64e = function (d, b) {\n    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))\n        ;\n    return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];\n};\n// extra field length\nvar exfl = function (ex) {\n    var le = 0;\n    if (ex) {\n        for (var k in ex) {\n            var l = ex[k].length;\n            if (l > 65535)\n                err(9);\n            le += l + 4;\n        }\n    }\n    return le;\n};\n// write zip header\nvar wzh = function (d, b, f, fn, u, c, ce, co) {\n    var fl = fn.length, ex = f.extra, col = co && co.length;\n    var exl = exfl(ex);\n    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;\n    if (ce != null)\n        d[b++] = 20, d[b++] = f.os;\n    d[b] = 20, b += 2; // spec compliance? what's that?\n    d[b++] = (f.flag << 1) | (c < 0 && 8), d[b++] = u && 8;\n    d[b++] = f.compression & 255, d[b++] = f.compression >> 8;\n    var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;\n    if (y < 0 || y > 119)\n        err(10);\n    wbytes(d, b, (y << 25) | ((dt.getMonth() + 1) << 21) | (dt.getDate() << 16) | (dt.getHours() << 11) | (dt.getMinutes() << 5) | (dt.getSeconds() >> 1)), b += 4;\n    if (c != -1) {\n        wbytes(d, b, f.crc);\n        wbytes(d, b + 4, c < 0 ? -c - 2 : c);\n        wbytes(d, b + 8, f.size);\n    }\n    wbytes(d, b + 12, fl);\n    wbytes(d, b + 14, exl), b += 16;\n    if (ce != null) {\n        wbytes(d, b, col);\n        wbytes(d, b + 6, f.attrs);\n        wbytes(d, b + 10, ce), b += 14;\n    }\n    d.set(fn, b);\n    b += fl;\n    if (exl) {\n        for (var k in ex) {\n            var exf = ex[k], l = exf.length;\n            wbytes(d, b, +k);\n            wbytes(d, b + 2, l);\n            d.set(exf, b + 4), b += 4 + l;\n        }\n    }\n    if (col)\n        d.set(co, b), b += col;\n    return b;\n};\n// write zip footer (end of central directory)\nvar wzf = function (o, b, c, d, e) {\n    wbytes(o, b, 0x6054B50); // skip disk\n    wbytes(o, b + 8, c);\n    wbytes(o, b + 10, c);\n    wbytes(o, b + 12, d);\n    wbytes(o, b + 16, e);\n};\n/**\n * A pass-through stream to keep data uncompressed in a ZIP archive.\n */\nvar ZipPassThrough = /*#__PURE__*/ (function () {\n    /**\n     * Creates a pass-through stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     */\n    function ZipPassThrough(filename) {\n        this.filename = filename;\n        this.c = crc();\n        this.size = 0;\n        this.compression = 0;\n    }\n    /**\n     * Processes a chunk and pushes to the output stream. You can override this\n     * method in a subclass for custom behavior, but by default this passes\n     * the data through. You must call this.ondata(err, chunk, final) at some\n     * point in this method.\n     * @param chunk The chunk to process\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.process = function (chunk, final) {\n        this.ondata(null, chunk, final);\n    };\n    /**\n     * Pushes a chunk to be added. If you are subclassing this with a custom\n     * compression algorithm, note that you must push data from the source\n     * file only, pre-compression.\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        this.c.p(chunk);\n        this.size += chunk.length;\n        if (final)\n            this.crc = this.c.d();\n        this.process(chunk, final || false);\n    };\n    return ZipPassThrough;\n}());\nexport { ZipPassThrough };\n// I don't extend because TypeScript extension adds 1kB of runtime bloat\n/**\n * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate\n * for better performance\n */\nvar ZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function ZipDeflate(filename, opts) {\n        var _this = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new Deflate(opts, function (dat, final) {\n            _this.ondata(null, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n    }\n    ZipDeflate.prototype.process = function (chunk, final) {\n        try {\n            this.d.push(chunk, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return ZipDeflate;\n}());\nexport { ZipDeflate };\n/**\n * Asynchronous streaming DEFLATE compression for ZIP archives\n */\nvar AsyncZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function AsyncZipDeflate(filename, opts) {\n        var _this = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new AsyncDeflate(opts, function (err, dat, final) {\n            _this.ondata(err, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n        this.terminate = this.d.terminate;\n    }\n    AsyncZipDeflate.prototype.process = function (chunk, final) {\n        this.d.push(chunk, final);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return AsyncZipDeflate;\n}());\nexport { AsyncZipDeflate };\n// TODO: Better tree shaking\n/**\n * A zippable archive to which files can incrementally be added\n */\nvar Zip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an empty ZIP archive to which files can be added\n     * @param cb The callback to call whenever data for the generated ZIP archive\n     *           is available\n     */\n    function Zip(cb) {\n        this.ondata = cb;\n        this.u = [];\n        this.d = 1;\n    }\n    /**\n     * Adds a file to the ZIP archive\n     * @param file The file stream to add\n     */\n    Zip.prototype.add = function (file) {\n        var _this = this;\n        if (!this.ondata)\n            err(5);\n        // finishing or finished\n        if (this.d & 2)\n            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, false);\n        else {\n            var f = strToU8(file.filename), fl_1 = f.length;\n            var com = file.comment, o = com && strToU8(com);\n            var u = fl_1 != file.filename.length || (o && (com.length != o.length));\n            var hl_1 = fl_1 + exfl(file.extra) + 30;\n            if (fl_1 > 65535)\n                this.ondata(err(11, 0, 1), null, false);\n            var header = new u8(hl_1);\n            wzh(header, 0, file, f, u, -1);\n            var chks_1 = [header];\n            var pAll_1 = function () {\n                for (var _i = 0, chks_2 = chks_1; _i < chks_2.length; _i++) {\n                    var chk = chks_2[_i];\n                    _this.ondata(null, chk, false);\n                }\n                chks_1 = [];\n            };\n            var tr_1 = this.d;\n            this.d = 0;\n            var ind_1 = this.u.length;\n            var uf_1 = mrg(file, {\n                f: f,\n                u: u,\n                o: o,\n                t: function () {\n                    if (file.terminate)\n                        file.terminate();\n                },\n                r: function () {\n                    pAll_1();\n                    if (tr_1) {\n                        var nxt = _this.u[ind_1 + 1];\n                        if (nxt)\n                            nxt.r();\n                        else\n                            _this.d = 1;\n                    }\n                    tr_1 = 1;\n                }\n            });\n            var cl_1 = 0;\n            file.ondata = function (err, dat, final) {\n                if (err) {\n                    _this.ondata(err, dat, final);\n                    _this.terminate();\n                }\n                else {\n                    cl_1 += dat.length;\n                    chks_1.push(dat);\n                    if (final) {\n                        var dd = new u8(16);\n                        wbytes(dd, 0, 0x8074B50);\n                        wbytes(dd, 4, file.crc);\n                        wbytes(dd, 8, cl_1);\n                        wbytes(dd, 12, file.size);\n                        chks_1.push(dd);\n                        uf_1.c = cl_1, uf_1.b = hl_1 + cl_1 + 16, uf_1.crc = file.crc, uf_1.size = file.size;\n                        if (tr_1)\n                            uf_1.r();\n                        tr_1 = 1;\n                    }\n                    else if (tr_1)\n                        pAll_1();\n                }\n            };\n            this.u.push(uf_1);\n        }\n    };\n    /**\n     * Ends the process of adding files and prepares to emit the final chunks.\n     * This *must* be called after adding all desired files for the resulting\n     * ZIP file to work properly.\n     */\n    Zip.prototype.end = function () {\n        var _this = this;\n        if (this.d & 2) {\n            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, true);\n            return;\n        }\n        if (this.d)\n            this.e();\n        else\n            this.u.push({\n                r: function () {\n                    if (!(_this.d & 1))\n                        return;\n                    _this.u.splice(-1, 1);\n                    _this.e();\n                },\n                t: function () { }\n            });\n        this.d = 3;\n    };\n    Zip.prototype.e = function () {\n        var bt = 0, l = 0, tl = 0;\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);\n        }\n        var out = new u8(tl + 22);\n        for (var _b = 0, _c = this.u; _b < _c.length; _b++) {\n            var f = _c[_b];\n            wzh(out, bt, f, f.f, f.u, -f.c - 2, l, f.o);\n            bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;\n        }\n        wzf(out, bt, this.u.length, tl, l);\n        this.ondata(null, out, true);\n        this.d = 2;\n    };\n    /**\n     * A method to terminate any internal workers used by the stream. Subsequent\n     * calls to add() will fail.\n     */\n    Zip.prototype.terminate = function () {\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            f.t();\n        }\n        this.d = 2;\n    };\n    return Zip;\n}());\nexport { Zip };\nexport function zip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    var r = {};\n    fltn(data, '', r, opts);\n    var k = Object.keys(r);\n    var lft = k.length, o = 0, tot = 0;\n    var slft = lft, files = new Array(lft);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var cbd = function (a, b) {\n        mt(function () { cb(a, b); });\n    };\n    mt(function () { cbd = cb; });\n    var cbf = function () {\n        var out = new u8(tot + 22), oe = o, cdl = tot - o;\n        tot = 0;\n        for (var i = 0; i < slft; ++i) {\n            var f = files[i];\n            try {\n                var l = f.c.length;\n                wzh(out, tot, f, f.f, f.u, l);\n                var badd = 30 + f.f.length + exfl(f.extra);\n                var loc = tot + badd;\n                out.set(f.c, loc);\n                wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;\n            }\n            catch (e) {\n                return cbd(e, null);\n            }\n        }\n        wzf(out, o, files.length, cdl, oe);\n        cbd(null, out);\n    };\n    if (!lft)\n        cbf();\n    var _loop_1 = function (i) {\n        var fn = k[i];\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var c = crc(), size = file.length;\n        c.p(file);\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        var compression = p.level == 0 ? 0 : 8;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cbd(e, null);\n            }\n            else {\n                var l = d.length;\n                files[i] = mrg(p, {\n                    size: size,\n                    crc: c.d(),\n                    c: d,\n                    f: f,\n                    m: m,\n                    u: s != fn.length || (m && (com.length != ms)),\n                    compression: compression\n                });\n                o += 30 + s + exl + l;\n                tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n                if (!--lft)\n                    cbf();\n            }\n        };\n        if (s > 65535)\n            cbl(err(11, 0, 1), null);\n        if (!compression)\n            cbl(null, file);\n        else if (size < 160000) {\n            try {\n                cbl(null, deflateSync(file, p));\n            }\n            catch (e) {\n                cbl(e, null);\n            }\n        }\n        else\n            term.push(deflate(file, p, cbl));\n    };\n    // Cannot use lft because it can decrease\n    for (var i = 0; i < slft; ++i) {\n        _loop_1(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously creates a ZIP file. Prefer using `zip` for better performance\n * with more than one file.\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @returns The generated ZIP archive\n */\nexport function zipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var r = {};\n    var files = [];\n    fltn(data, '', r, opts);\n    var o = 0;\n    var tot = 0;\n    for (var fn in r) {\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var compression = p.level == 0 ? 0 : 8;\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        if (s > 65535)\n            err(11);\n        var d = compression ? deflateSync(file, p) : file, l = d.length;\n        var c = crc();\n        c.p(file);\n        files.push(mrg(p, {\n            size: file.length,\n            crc: c.d(),\n            c: d,\n            f: f,\n            m: m,\n            u: s != fn.length || (m && (com.length != ms)),\n            o: o,\n            compression: compression\n        }));\n        o += 30 + s + exl + l;\n        tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n    }\n    var out = new u8(tot + 22), oe = o, cdl = tot - o;\n    for (var i = 0; i < files.length; ++i) {\n        var f = files[i];\n        wzh(out, f.o, f, f.f, f.u, f.c.length);\n        var badd = 30 + f.f.length + exfl(f.extra);\n        out.set(f.c, f.o + badd);\n        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);\n    }\n    wzf(out, o, files.length, cdl, oe);\n    return out;\n}\n/**\n * Streaming pass-through decompression for ZIP archives\n */\nvar UnzipPassThrough = /*#__PURE__*/ (function () {\n    function UnzipPassThrough() {\n    }\n    UnzipPassThrough.prototype.push = function (data, final) {\n        this.ondata(null, data, final);\n    };\n    UnzipPassThrough.compression = 0;\n    return UnzipPassThrough;\n}());\nexport { UnzipPassThrough };\n/**\n * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for\n * better performance.\n */\nvar UnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function UnzipInflate() {\n        var _this = this;\n        this.i = new Inflate(function (dat, final) {\n            _this.ondata(null, dat, final);\n        });\n    }\n    UnzipInflate.prototype.push = function (data, final) {\n        try {\n            this.i.push(data, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    UnzipInflate.compression = 8;\n    return UnzipInflate;\n}());\nexport { UnzipInflate };\n/**\n * Asynchronous streaming DEFLATE decompression for ZIP archives\n */\nvar AsyncUnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function AsyncUnzipInflate(_, sz) {\n        var _this = this;\n        if (sz < 320000) {\n            this.i = new Inflate(function (dat, final) {\n                _this.ondata(null, dat, final);\n            });\n        }\n        else {\n            this.i = new AsyncInflate(function (err, dat, final) {\n                _this.ondata(err, dat, final);\n            });\n            this.terminate = this.i.terminate;\n        }\n    }\n    AsyncUnzipInflate.prototype.push = function (data, final) {\n        if (this.i.terminate)\n            data = slc(data, 0);\n        this.i.push(data, final);\n    };\n    AsyncUnzipInflate.compression = 8;\n    return AsyncUnzipInflate;\n}());\nexport { AsyncUnzipInflate };\n/**\n * A ZIP archive decompression stream that emits files as they are discovered\n */\nvar Unzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a ZIP decompression stream\n     * @param cb The callback to call whenever a file in the ZIP archive is found\n     */\n    function Unzip(cb) {\n        this.onfile = cb;\n        this.k = [];\n        this.o = {\n            0: UnzipPassThrough\n        };\n        this.p = et;\n    }\n    /**\n     * Pushes a chunk to be unzipped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzip.prototype.push = function (chunk, final) {\n        var _this = this;\n        if (!this.onfile)\n            err(5);\n        if (!this.p)\n            err(4);\n        if (this.c > 0) {\n            var len = Math.min(this.c, chunk.length);\n            var toAdd = chunk.subarray(0, len);\n            this.c -= len;\n            if (this.d)\n                this.d.push(toAdd, !this.c);\n            else\n                this.k[0].push(toAdd);\n            chunk = chunk.subarray(len);\n            if (chunk.length)\n                return this.push(chunk, final);\n        }\n        else {\n            var f = 0, i = 0, is = void 0, buf = void 0;\n            if (!this.p.length)\n                buf = chunk;\n            else if (!chunk.length)\n                buf = this.p;\n            else {\n                buf = new u8(this.p.length + chunk.length);\n                buf.set(this.p), buf.set(chunk, this.p.length);\n            }\n            var l = buf.length, oc = this.c, add = oc && this.d;\n            var _loop_2 = function () {\n                var _a;\n                var sig = b4(buf, i);\n                if (sig == 0x4034B50) {\n                    f = 1, is = i;\n                    this_1.d = null;\n                    this_1.c = 0;\n                    var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);\n                    if (l > i + 30 + fnl + es) {\n                        var chks_3 = [];\n                        this_1.k.unshift(chks_3);\n                        f = 2;\n                        var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);\n                        var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);\n                        if (sc_1 == 4294967295) {\n                            _a = dd ? [-2] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];\n                        }\n                        else if (dd)\n                            sc_1 = -1;\n                        i += es;\n                        this_1.c = sc_1;\n                        var d_1;\n                        var file_1 = {\n                            name: fn_1,\n                            compression: cmp_1,\n                            start: function () {\n                                if (!file_1.ondata)\n                                    err(5);\n                                if (!sc_1)\n                                    file_1.ondata(null, et, true);\n                                else {\n                                    var ctr = _this.o[cmp_1];\n                                    if (!ctr)\n                                        file_1.ondata(err(14, 'unknown compression type ' + cmp_1, 1), null, false);\n                                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);\n                                    d_1.ondata = function (err, dat, final) { file_1.ondata(err, dat, final); };\n                                    for (var _i = 0, chks_4 = chks_3; _i < chks_4.length; _i++) {\n                                        var dat = chks_4[_i];\n                                        d_1.push(dat, false);\n                                    }\n                                    if (_this.k[0] == chks_3 && _this.c)\n                                        _this.d = d_1;\n                                    else\n                                        d_1.push(et, true);\n                                }\n                            },\n                            terminate: function () {\n                                if (d_1 && d_1.terminate)\n                                    d_1.terminate();\n                            }\n                        };\n                        if (sc_1 >= 0)\n                            file_1.size = sc_1, file_1.originalSize = su_1;\n                        this_1.onfile(file_1);\n                    }\n                    return \"break\";\n                }\n                else if (oc) {\n                    if (sig == 0x8074B50) {\n                        is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                    else if (sig == 0x2014B50) {\n                        is = i -= 4, f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                }\n            };\n            var this_1 = this;\n            for (; i < l - 4; ++i) {\n                var state_1 = _loop_2();\n                if (state_1 === \"break\")\n                    break;\n            }\n            this.p = et;\n            if (oc < 0) {\n                var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);\n                if (add)\n                    add.push(dat, !!f);\n                else\n                    this.k[+(f == 2)].push(dat);\n            }\n            if (f & 2)\n                return this.push(buf.subarray(i), final);\n            this.p = buf.subarray(i);\n        }\n        if (final) {\n            if (this.c)\n                err(13);\n            this.p = null;\n        }\n    };\n    /**\n     * Registers a decoder with the stream, allowing for files compressed with\n     * the compression type provided to be expanded correctly\n     * @param decoder The decoder constructor\n     */\n    Unzip.prototype.register = function (decoder) {\n        this.o[decoder.compression] = decoder;\n    };\n    return Unzip;\n}());\nexport { Unzip };\nvar mt = typeof queueMicrotask == 'function' ? queueMicrotask : typeof setTimeout == 'function' ? setTimeout : function (fn) { fn(); };\nexport function unzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var files = {};\n    var cbd = function (a, b) {\n        mt(function () { cb(a, b); });\n    };\n    mt(function () { cbd = cb; });\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558) {\n            cbd(err(13, 0, 1), null);\n            return tAll;\n        }\n    }\n    ;\n    var lft = b2(data, e + 8);\n    if (lft) {\n        var c = lft;\n        var o = b4(data, e + 16);\n        var z = o == 4294967295 || c == 65535;\n        if (z) {\n            var ze = b4(data, e - 12);\n            z = b4(data, ze) == 0x6064B50;\n            if (z) {\n                c = lft = b4(data, ze + 32);\n                o = b4(data, ze + 48);\n            }\n        }\n        var fltr = opts && opts.filter;\n        var _loop_3 = function (i) {\n            var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n            o = no;\n            var cbl = function (e, d) {\n                if (e) {\n                    tAll();\n                    cbd(e, null);\n                }\n                else {\n                    if (d)\n                        files[fn] = d;\n                    if (!--lft)\n                        cbd(null, files);\n                }\n            };\n            if (!fltr || fltr({\n                name: fn,\n                size: sc,\n                originalSize: su,\n                compression: c_1\n            })) {\n                if (!c_1)\n                    cbl(null, slc(data, b, b + sc));\n                else if (c_1 == 8) {\n                    var infl = data.subarray(b, b + sc);\n                    // Synchronously decompress under 512KB, or barely-compressed data\n                    if (su < 524288 || sc > 0.8 * su) {\n                        try {\n                            cbl(null, inflateSync(infl, { out: new u8(su) }));\n                        }\n                        catch (e) {\n                            cbl(e, null);\n                        }\n                    }\n                    else\n                        term.push(inflate(infl, { size: su }, cbl));\n                }\n                else\n                    cbl(err(14, 'unknown compression type ' + c_1, 1), null);\n            }\n            else\n                cbl(null, null);\n        };\n        for (var i = 0; i < c; ++i) {\n            _loop_3(i);\n        }\n    }\n    else\n        cbd(null, {});\n    return tAll;\n}\n/**\n * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better\n * performance with more than one file.\n * @param data The raw compressed ZIP file\n * @param opts The ZIP extraction options\n * @returns The decompressed files\n */\nexport function unzipSync(data, opts) {\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558)\n            err(13);\n    }\n    ;\n    var c = b2(data, e + 8);\n    if (!c)\n        return {};\n    var o = b4(data, e + 16);\n    var z = o == 4294967295 || c == 65535;\n    if (z) {\n        var ze = b4(data, e - 12);\n        z = b4(data, ze) == 0x6064B50;\n        if (z) {\n            c = b4(data, ze + 32);\n            o = b4(data, ze + 48);\n        }\n    }\n    var fltr = opts && opts.filter;\n    for (var i = 0; i < c; ++i) {\n        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        if (!fltr || fltr({\n            name: fn,\n            size: sc,\n            originalSize: su,\n            compression: c_2\n        })) {\n            if (!c_2)\n                files[fn] = slc(data, b, b + sc);\n            else if (c_2 == 8)\n                files[fn] = inflateSync(data.subarray(b, b + sc), { out: new u8(su) });\n            else\n                err(14, 'unknown compression type ' + c_2);\n        }\n    }\n    return files;\n}\n","export interface PFMData\r\n{\r\n    format: 'PF' | 'Pf',\r\n    scaleFactor: string,\r\n    width:number,\r\n    height:number,\r\n    grayscale?:Float32Array,\r\n    rgb?:[Float32Array, Float32Array,Float32Array]\r\n}\r\n\r\n// PFM format\r\n// 3\r\n// lines\r\n// 1: identifier    \"PF\"\"Pf\"\r\n// 2: width height  \r\n// 3: -1.0          -+\r\n\r\n\r\nexport class PFMLoader\r\n{\r\n    public static Load(bytes:Uint8Array):PFMData // gray | rgb\r\n    {\r\n        const textDecoder = new TextDecoder(\"ascii\");\r\n        let offset = 0;\r\n\r\n        function readLine(): string {\r\n            let start = offset;\r\n            while (offset < bytes.length && bytes[offset] !== 0x0A) offset++; // LF\r\n            const line = textDecoder.decode(bytes.slice(start, offset));\r\n            offset++; // skip LF\r\n            return line.trim();\r\n        }\r\n\r\n        // 1.  \"PF\" ()  \"Pf\" ()\r\n        const format = readLine();\r\n        const isColor = format === \"PF\";\r\n        if (!isColor && format !== \"Pf\") {\r\n            throw new Error(\"Unsupported PFM format: \" + format);\r\n        }\r\n\r\n        // 2. \r\n        const sizeLine = readLine();\r\n        const [widthStr, heightStr] = sizeLine.split(\" \");\r\n        const width = parseInt(widthStr, 10);\r\n        const height = parseInt(heightStr, 10);\r\n\r\n        if (isNaN(width) || isNaN(height)) {\r\n            throw new Error(\"Invalid size: \" + sizeLine);\r\n        }\r\n\r\n        // 3.  float\r\n        const scaleLine = readLine();\r\n        const scaleEndianness = parseFloat(scaleLine);\r\n        const scale = Math.abs(scaleEndianness);\r\n        const littleEndian = scaleEndianness < 0;\r\n\r\n        // 4. \r\n        const numChannels = isColor ? 3 : 1;\r\n        const numPixels = width * height * numChannels;\r\n\r\n        //const dataBytes = bytes.slice(offset);\r\n        //const dataView = new DataView(dataBytes.buffer, dataBytes.byteOffset, dataBytes.byteLength);\r\n        const dataView =new DataView(bytes.buffer, bytes.byteOffset + offset, bytes.byteLength - offset);\r\n        const floatData = new Float32Array(numPixels);\r\n        for (let i = 0; i < numPixels; i++) {\r\n            floatData[i] = dataView.getFloat32(i * 4, littleEndian) * scale;\r\n        }\r\n\r\n        const pfmData:PFMData = {format:format, scaleFactor:scaleLine, width:width, height:height};\r\n        // 5. 2 [channel][y * width + x]\r\n        if (isColor) {\r\n\r\n            const r = new Float32Array(width * height);\r\n            const g = new Float32Array(width * height);\r\n            const b = new Float32Array(width * height);\r\n\r\n            for(let y = 0; y < height; y++){\r\n                const src_y = height - 1 - y;\r\n                for (let x = 0; x < width; x++) {\r\n                    const src_i = src_y * width + x;\r\n                    const dst_i = y * width + x;\r\n                    r[dst_i] = floatData[src_i * 3 + 0];\r\n                    g[dst_i] = floatData[src_i * 3 + 1];\r\n                    b[dst_i] = floatData[src_i * 3 + 2];\r\n                }\r\n            }\r\n            \r\n            pfmData.rgb = [r, g, b];\r\n        } \r\n        else {\r\n            let values = new Float32Array(width * height);\r\n            for(let y = 0; y < height; y++){\r\n                const src_y = height - 1 - y;\r\n                for (let x = 0; x < width; x++) {\r\n                    const src_i = src_y * width + x;\r\n                    const dst_i = y * width + x;\r\n                    values[dst_i] = floatData[src_i];\r\n                }\r\n            }\r\n\r\n            pfmData.grayscale = values;\r\n        }\r\n\r\n        return pfmData;\r\n    }\r\n}","export class Image2d\r\n{\r\n    private _data;\r\n    private _width = 0;\r\n    private _height = 0;\r\n\r\n    constructor(data:Float32Array, width:number, height:number)\r\n    {\r\n        if(data.length != width * height) throw new Error(\"invalid argument. data length must be 'width * height' size.\");\r\n        \r\n        this._data = data;\r\n        this._width = width;\r\n        this._height = height;\r\n    }\r\n\r\n    getValue(x:number, y:number)\r\n    {\r\n        return this._data[y * this._width + x];\r\n    }\r\n\r\n    get values() {return this._data;}\r\n\r\n    get width(){return this._width;}\r\n    get height(){return this._height;}\r\n}","export class Point\r\n{\r\n    private _x:number;\r\n    private _y:number;\r\n    private _empty = true;\r\n    constructor();\r\n    constructor(x:number, y:number);\r\n\r\n    constructor(x=0, y=0)\r\n    {\r\n        this._x = x;\r\n        this._y = y;\r\n\r\n        this._empty = false;\r\n    }\r\n\r\n    get x() {return this._x;}\r\n    set x(x:number){this._x = x; this._empty = false;}\r\n\r\n    get y() {return this._y;}\r\n    set y(y:number){this._y = y; this._empty = false;}\r\n    \r\n    get isEmpty(){return this._empty;}\r\n};","import { Point } from \"../core/Point\";\r\nimport { PointerHandler } from \"../events/handler\";\r\n\r\ntype MarkerPointerHandler = (sender:Marker, e:PointerEvent)=>void;\r\n\r\nexport class Marker \r\n{\r\n    private _element;\r\n    private _tipsElement;\r\n    private _finderElement;\r\n    private _visible = true;\r\n    private _tipsVisible = true;\r\n    private _text = \"\";\r\n    private _point = new Point();\r\n    private _location = new Point(); // client point\r\n    private _pointerDownLocation = new Point();\r\n\r\n    private _clickListeners:MarkerPointerHandler[] = []\r\n    \r\n    constructor(){\r\n        this._element = this.createElement();\r\n        this._tipsElement = this._element.querySelector(\".tips\") as HTMLElement;\r\n        this._finderElement = this._element.querySelector(\".finder\") as HTMLElement;\r\n    }\r\n\r\n    private createElement()\r\n    {\r\n        const elem = document.createElement(\"div\");\r\n        elem.classList.add(\"marker\");\r\n\r\n        const finder = document.createElement(\"div\");\r\n        finder.classList.add(\"finder\");\r\n        finder.addEventListener(\"pointerdown\",this.onFinderPointerDown);\r\n\r\n        const tips = document.createElement(\"div\");\r\n        tips.classList.add(\"tips\");\r\n\r\n        elem.appendChild(finder);\r\n        elem.appendChild(tips);\r\n\r\n        return elem;\r\n    }\r\n    get imageCoord(){return this._point;}\r\n    set imageCoord(point:Point){this._point = point;}\r\n    \r\n    get text(){return this._text;}\r\n    set text(text:string){\r\n        this._text = text;\r\n\r\n        this._tipsElement.textContent = text;\r\n    }\r\n\r\n    get location(){return this._location;}\r\n    set location(location:Point){\r\n        this._location = location;\r\n\r\n        this._element.style.left = location.x + \"px\";\r\n        this._element.style.top = location.y + \"px\";\r\n    }\r\n\r\n    get visible(){return this._visible;}\r\n    set visible(tf:boolean){\r\n        this._visible=tf;\r\n        this._element.style.display = tf ? \"\" : \"none\";\r\n    }\r\n\r\n    get tipsVisible(){return this._tipsVisible;}\r\n    set tipsVisible(tf:boolean)\r\n    {\r\n        this._tipsVisible = tf;\r\n        this._tipsElement.style.display = tf ? \"\" : \"none\";\r\n    }\r\n\r\n    private onFinderPointerDown=(e:PointerEvent)=>{\r\n        this._pointerDownLocation = new Point(e.offsetX, e.offsetY);\r\n\r\n        e.stopPropagation();\r\n\r\n        this._finderElement.addEventListener(\"pointermove\", this.onFinderPointerMove);\r\n        this._finderElement.addEventListener(\"pointerup\", this.onFinderPointerUp);\r\n    }\r\n    private onFinderPointerMove=(e:PointerEvent)=>{\r\n    \r\n    }\r\n    private onFinderPointerUp=(e:PointerEvent)=>{\r\n        if(this._pointerDownLocation.x == e.offsetX &&\r\n           this._pointerDownLocation.y == e.offsetY){\r\n            this.emitClick(e);\r\n        }\r\n\r\n        this._finderElement.removeEventListener(\"pointermove\", this.onFinderPointerMove);\r\n        this._finderElement.removeEventListener(\"pointerup\", this.onFinderPointerUp);\r\n    }\r\n\r\n    private emitClick(e:PointerEvent)\r\n    {\r\n        for(let i=0;i<this._clickListeners.length;i++){\r\n            this._clickListeners[i](this, e);\r\n        }\r\n    }\r\n    onClick(handler:MarkerPointerHandler){\r\n        this._clickListeners.push(handler);\r\n    }\r\n    offClick(handler:MarkerPointerHandler){\r\n        const idx = this._clickListeners.indexOf(handler);\r\n        if(idx != - 1) this._clickListeners.splice(idx, 1);\r\n    }\r\n\r\n    get element(){return this._element as HTMLElement;}\r\n}","import { ImageTypes } from \"../types/ImageTypes\";\r\n\r\nexport function imageTypeToName(type:ImageTypes)\r\n{\r\n    switch(type)\r\n    {\r\n        case \"picture\": return \"\";\r\n        case \"cof\": return \"\";\r\n        case \"lm\": return \"\";\r\n        case \"lmc\": return \"\";\r\n        default: return \"\";\r\n    }\r\n}\r\n\r\nexport async function RgbaArrayFromjpgFile(file: File): Promise<Uint8ClampedArray> {\r\n  // File  HTMLImageElement\r\n  const url = URL.createObjectURL(file);\r\n  const img = await new Promise<HTMLImageElement>((resolve, reject) => {\r\n    const i = new Image();\r\n    i.onload = () => resolve(i);\r\n    i.onerror = reject;\r\n    i.src = url;\r\n  });\r\n\r\n  // Canvas\r\n  const canvas = document.createElement(\"canvas\");\r\n  canvas.width = img.width;\r\n  canvas.height = img.height;\r\n  const ctx = canvas.getContext(\"2d\")!;\r\n  ctx.drawImage(img, 0, 0);\r\n\r\n  // RGBA\r\n  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\r\n\r\n  URL.revokeObjectURL(url); // \r\n  return imageData.data; // Uint8ClampedArray [r,g,b,a,r,g,b,a,...]\r\n}\r\n\r\nexport function clamp(value:number, min:number, max:number){\r\n  return Math.max(min, Math.min(max, value));\r\n}","import { clamp } from \"../utilities/ImageNames\";\r\n\r\nconst CANVAS_WIDTH = 80;\r\nconst CANVAS_HEIGHT = 120;\r\nconst SCALEBAR_WIDTH = 20;\r\n\r\nconst verticalMargin = 5; // \r\nconst PIXEL_OFFSET = 0.5;\r\n\r\nexport class Scalebar \r\n{\r\n    private _element;\r\n    private _canvas;\r\n    private _ctx;\r\n    private _min = 0;\r\n    private _max = 0;\r\n    private _visible = true;\r\n    \r\n    constructor(){\r\n        this._element = this.createElement();\r\n        this._canvas = this._element.querySelector(\".drawarea\") as HTMLCanvasElement;\r\n        this._ctx = this._canvas.getContext(\"2d\")!;\r\n    }\r\n\r\n    private createElement(){\r\n        const scalebar = document.createElement(\"div\");\r\n        scalebar.classList.add(\"scalebar\");\r\n\r\n        const canvas = document.createElement(\"canvas\");\r\n        canvas.classList.add(\"drawarea\");\r\n        canvas.width = CANVAS_WIDTH;\r\n        canvas.height = CANVAS_HEIGHT;\r\n        scalebar.appendChild(canvas);\r\n\r\n        return scalebar;\r\n    }\r\n\r\n    /**  */\r\n    drawLmScale(min:number, max:number)\r\n    {\r\n        // \r\n        const steps = 5;\r\n        const ctx = this._ctx;\r\n\r\n        ctx.clearRect(0,0, this._canvas.width, this._canvas.height);\r\n\r\n        // \r\n        const scalebarWidth = SCALEBAR_WIDTH;\r\n        const scalebarHeight = this._canvas.height - (verticalMargin * 2);\r\n        for(let i=0;i<scalebarHeight;i++)\r\n        {\r\n            const t = 1 - (i / scalebarHeight) * 2;\r\n\r\n            const r = Math.floor(clamp(1.5 - Math.abs(2.0 * t + 1.0), 0.15, 0.85) * 255);\r\n\t\t    const g = Math.floor(clamp(1.5 - Math.abs(2.0 * t), 0.15, 0.85) * 255);\r\n\t\t    const b = Math.floor(clamp(1.5 - Math.abs(2.0 * t - 1.0), 0.15, 0.85) * 255);\r\n\r\n            ctx.fillStyle = `rgb(${r} ${g} ${b})`;\r\n            ctx.fillRect(0 + PIXEL_OFFSET, verticalMargin + (scalebarHeight - i)+PIXEL_OFFSET, scalebarWidth, 1); // 1px\r\n        }\r\n        // \r\n        ctx.strokeRect(0+PIXEL_OFFSET, verticalMargin+PIXEL_OFFSET, scalebarWidth, scalebarHeight);\r\n\r\n        // \r\n        ctx.fillStyle = \"black\";\r\n\r\n        const logMin = Math.log10(min);\r\n        const logMax = Math.log10(max);\r\n\r\n        const step = (logMax - logMin) / steps;\r\n        let ticks:number[] = [min];\r\n        for(let i =1;i<steps;i++)\r\n        {\r\n            ticks.push(Math.pow(10, (logMin + step * i)));\r\n        }\r\n        ticks.push(max);\r\n\r\n        const interval = scalebarHeight / steps;\r\n        for(let i=0;i<ticks.length;i++){\r\n            const y = (scalebarHeight + verticalMargin) - i * interval + PIXEL_OFFSET;\r\n            const tickWidth = (i == 0 || i == ticks.length - 1 ? 8 : 5);\r\n            ctx.beginPath();\r\n            ctx.moveTo(scalebarWidth, y);\r\n            ctx.lineTo(scalebarWidth + tickWidth, y);\r\n            ctx.stroke();\r\n\r\n            //let value = upper - (i*interval);\r\n            //if(isLog) value = Math.pow(10, value);\r\n            const value = ticks[i];\r\n            let fixed = 0;\r\n            if(1 <= value) fixed = 0;\r\n            else {\r\n                fixed = Math.floor(Math.abs(Math.log10(value)));\r\n            }\r\n            \r\n            ctx.fillText(ticks[i].toFixed(fixed), scalebarWidth + 10, y+3);\r\n        }\r\n    }\r\n\r\n    drawLmcScale()\r\n    {\r\n        // \r\n        const ctx = this._ctx;\r\n\r\n        ctx.clearRect(0,0, this._canvas.width, this._canvas.height);\r\n\r\n        //const points = [0, 1/10, 1/3, 1/2, 2, 3, 10, 20];\r\n        const labels = [\"0\", \"1/10\", \"1/3\", \"1/2\", \"2\", \"3\", \"10\", \"\"];\r\n        const colors = [\"#80f\"/*violet*/, \"#00f\"/*blue*/, \"#0ff\"/*lightBlue*/, \"#f5f5f5\"/* whitesmoke*/, \"#ff0\"/*yellow*/, \"#f80\"/*orange*/, \"#f00\"/*red*/];\r\n\r\n        const scalebarWidth = SCALEBAR_WIDTH;\r\n        const scalebarHeight = this._canvas.height - (verticalMargin * 2);\r\n\r\n        const interval = scalebarHeight / colors.length;\r\n        \r\n        // \r\n        for(let i=0;i<colors.length;i++){\r\n            let y = scalebarHeight + verticalMargin - (i * interval);\r\n\r\n            ctx.fillStyle = colors[i];\r\n            ctx.fillRect(0+PIXEL_OFFSET, (y - interval) + PIXEL_OFFSET, scalebarWidth, interval + PIXEL_OFFSET);\r\n        }\r\n        \r\n        ctx.fillStyle = \"black\";\r\n        // \r\n        for(let i=0;i<=labels.length;i++){\r\n            let y = scalebarHeight + verticalMargin - (i * interval);\r\n\r\n            const tickWidth = i == 0 || i == labels.length-1 ? 8 : 5;\r\n            ctx.beginPath();\r\n            ctx.moveTo(scalebarWidth, y + PIXEL_OFFSET);\r\n            ctx.lineTo(scalebarWidth + tickWidth, y + PIXEL_OFFSET); \r\n            ctx.stroke();\r\n            ctx.closePath();\r\n\r\n            const label = labels[i]; \r\n            ctx.fillText(label, scalebarWidth + 10, y + 3 + PIXEL_OFFSET);\r\n        }\r\n\r\n        // \r\n        ctx.strokeRect(0+PIXEL_OFFSET, verticalMargin+PIXEL_OFFSET, scalebarWidth, scalebarHeight);\r\n    }\r\n    drawLmcScale2()\r\n    {\r\n        // \r\n        const steps = 5;\r\n        const ctx = this._ctx;\r\n\r\n        ctx.clearRect(0,0, this._canvas.width, this._canvas.height);\r\n\r\n        const points = [0.0001, 1/10, 1/3, 1/2, 2, 3, 10, 20];\r\n        const labels = [\"0\", \"1/10\", \"1/3\", \"1/2\", \"2\", \"3\", \"10\", \"\"];\r\n        const colors = [\"#80f\"/*violet*/, \"#00f\"/*blue*/, \"#0ff\"/*lightBlue*/, \"#f5f5f5\"/* whitesmoke*/, \"#ff0\"/*yellow*/, \"#f80\"/*orange*/, \"#f00\"/*red*/];\r\n\r\n        const scalebarWidth = SCALEBAR_WIDTH;\r\n        const scalebarHeight = this._canvas.height - (verticalMargin * 2);\r\n\r\n        ctx.font = ctx.font.replace(/\\d+px/, \"10px\");\r\n        const upper = Math.log10(points[points.length-1]);\r\n        const lower = points[0] === 0 ? -1.2 : Math.log10(points[0]);\r\n        const range = upper - lower;\r\n        const ratio = (scalebarHeight) / range;\r\n\r\n        for(let i=0;i<points.length;i++){\r\n            let y = getY(points[i]);\r\n            if(i == 0) y--;\r\n            //else if(i==points.length-1) y++; // \r\n            const tickWidth = i == 0 || i == points.length-1 ? 8 : 5;\r\n            ctx.beginPath();\r\n            ctx.moveTo(0, y);\r\n            ctx.lineTo(tickWidth, y); \r\n            ctx.stroke();\r\n\r\n            const label = labels[i]; \r\n            ctx.fillText(label, scalebarWidth + 10, y + 3);\r\n        }\r\n\r\n            function getY(value:number){\r\n                let absY = value === 0 ? 0 : Math.log10(value);\r\n                return Math.round(verticalMargin + (upper - absY) * ratio) + PIXEL_OFFSET;  //  + half pixel offset; \r\n            }\r\n\r\n            //const colorNames = [\"#000\"/*black*/, \"#00f\"/*blue*/, \"#0ff\"/*lightBlue*/, \"#0f0\"/*green*/, \"#ff0\"/*yellow*/, \"#f00\"/*red*/];\r\n            //const colorNames = [\"#00f\"/*blue*/, \"#0ff\"/*lightBlue*/, \"#0f0\"/*green*/, \"#f80\"/*orange*/, \"#ff0\"/*yellow*/, \"#f00\"/*red*/];\r\n            const colorNames = [\"#80f\"/*violet*/, \"#00f\"/*blue*/, \"#0ff\"/*lightBlue*/, \"#f5f5f5\"/* whitesmoke*/, \"#ff0\"/*yellow*/, \"#f80\"/*orange*/, \"#f00\"/*red*/];\r\n            for(let i=0;i<points.length-1;i++){\r\n                let y = (upper - Math.log10(points[i])) * ratio;\r\n                let nextY = (upper - Math.log10(points[i+1])) * ratio;\r\n                const areaHeight = y - nextY;\r\n                \r\n                ctx.fillStyle = colorNames[i];\r\n                ctx.fillRect(0, nextY, scalebarWidth, areaHeight);\r\n            }\r\n\r\n            // \r\n            ctx.strokeRect(0+PIXEL_OFFSET, verticalMargin+PIXEL_OFFSET, scalebarWidth, scalebarHeight);\r\n        }\r\n\r\n\r\n\r\n    get visible(){return this._visible;}\r\n    set visible(tf:boolean){\r\n        this._visible = tf;\r\n        this._element.style.display = tf ? \"\" : \"none\";\r\n    }\r\n    get element(){return this._element as HTMLElement;}\r\n}","import { ImageTypes } from \"../types/ImageTypes\";\r\nimport { imageTypeToName } from \"../utilities/ImageNames\";\r\n\r\ntype ChangeHandler = (value: Event) => void;\r\n\r\nexport class ImageSelector \r\n{\r\n    private _element;\r\n    private _imageTypes;\r\n    \r\n    private _listeners: ChangeHandler[] = [];\r\n\r\n    private _visible = true;\r\n\r\n    constructor(imageTypes:ImageTypes[]){\r\n        this._imageTypes = imageTypes;\r\n        this._element = this.createElement(imageTypes);\r\n        \r\n    }\r\n\r\n    private createElement(imageTypes:ImageTypes[])\r\n    {\r\n        const select = document.createElement(\"select\");\r\n        select.className = \"imageselector\"\r\n\r\n        for(let i=0;i<imageTypes.length;i++)\r\n        {\r\n            const option = document.createElement(\"option\");\r\n            option.textContent = imageTypeToName(imageTypes[i]);\r\n\r\n            select.appendChild(option);\r\n        }\r\n\r\n        // attach event\r\n        select.addEventListener(\"change\", (e:Event) => {\r\n            this.emitChanged(e);\r\n        });\r\n\r\n        return select;\r\n    }\r\n\r\n    onChanged(handler:ChangeHandler)\r\n    {\r\n        this._listeners.push(handler);\r\n    }\r\n\r\n    private emitChanged(e: Event) {\r\n        for (const h of this._listeners) h(e);\r\n    }\r\n\r\n    get visible(){return this._visible;}\r\n    set visible(tf:boolean){\r\n        this._visible = tf;\r\n        this._element.style.display = tf ? \"\" : \"none\";\r\n    }\r\n\r\n    get element(){return this._element as HTMLElement;}\r\n\r\n    get selectedImageType() { return this._imageTypes[this._element.selectedIndex];}\r\n    set selectedImageType(type:ImageTypes) { this._element.selectedIndex = this._imageTypes.indexOf(type);}\r\n}","import { Point } from \"./Point\";\r\n\r\nexport class Rectangle\r\n{\r\n    x:number;\r\n    y:number;\r\n    width:number;\r\n    height:number;\r\n\r\n    constructor();\r\n    constructor(x:number, y:number, width:number, height:number);\r\n    \r\n    constructor(x:number = 0, y:number =0, width:number=0, height:number=0){\r\n        this.x = x;\r\n        this.y = y;\r\n        this.width = width;\r\n        this.height = height;\r\n    }\r\n\r\n    get left(){return this.x;}\r\n    get top(){return this.y;}\r\n    get right() {return this.x + this.width;}\r\n    get bottom() {return this.y + this.height;}\r\n    get location(){return new Point(this.x, this.y);}\r\n    set location(point:Point){ \r\n        this.x = point.x;\r\n        this.y = point.y;\r\n    }\r\n    get isEmpty(){\r\n        return (this.x === 0 && this.y === 0 && this.width === 0 && this.height === 0);\r\n    }\r\n};","import { Rectangle } from \"../core/Rectangle\";\r\n\r\nexport class CanvasBase\r\n{\r\n    protected _canvas;\r\n    protected _ctx;\r\n    protected _width = 0;\r\n    protected _height = 0;\r\n    private _aspect = 0;\r\n    protected _bitmap:ImageBitmap | null = null;\r\n    protected _scale = 1.0;\r\n    protected _eye = {x:0.5, y:0.5};\r\n\r\n    constructor()\r\n    {\r\n        this._canvas = document.createElement(\"canvas\");\r\n        this._ctx = this._canvas.getContext(\"2d\")!;\r\n        this._ctx.imageSmoothingEnabled = false;\r\n    }\r\n    protected getImageData(){return this._ctx.getImageData(0,0, this._canvas.width, this._canvas.height);}\r\n    protected setImageData(imageData:ImageData){this._ctx.putImageData(imageData, 0,0);}\r\n\r\n\r\n    drawImage(image:ImageBitmap|null, rect:Rectangle)\r\n    {\r\n        this.clear();\r\n        if(image == null) return;\r\n\r\n        this._ctx.drawImage(image, rect.x, rect.y, rect.width, rect.height);\r\n    }\r\n\r\n    \r\n\r\n    setSize(width:number, height:number)\r\n    {\r\n        this._canvas.width = this._width = width;\r\n        this._canvas.height = this._height = height;\r\n\r\n        this._aspect = this._width / this._height;\r\n    }\r\n\r\n    get image(){return this._bitmap;}\r\n    set image(bitmap:ImageBitmap|null) {this._bitmap = bitmap;} \r\n\r\n    get scale(){return this._scale;}\r\n    set scale(scale:number){this._scale = Math.max(scale, 1.0);}\r\n\r\n    clear()\r\n    {\r\n        this._ctx.clearRect(0,0,this._canvas.width, this._canvas.height);\r\n    }\r\n\r\n    get element(){return this._canvas;}\r\n}","import { CanvasBase } from \"./CanvasBase\";\r\n\r\nexport class BackCanvas extends CanvasBase\r\n{\r\n\r\n    constructor()\r\n    {\r\n        super();\r\n        this.element.classList.add(\"backcanvas\");\r\n    }    \r\n}","import { CanvasBase } from \"./CanvasBase\";\r\nimport { Marker } from \"./Marker\";\r\n\r\nexport class MarkerContainer\r\n{\r\n    private _container;\r\n    private _markers:Marker[] = [];\r\n    constructor()\r\n    {\r\n        this._container = this.createElement();\r\n    }   \r\n\r\n    private createElement()\r\n    {\r\n        const container = document.createElement(\"div\");\r\n        container.classList.add(\"markercontainer\");\r\n\r\n        return container;\r\n    }\r\n\r\n    add(marker:Marker)\r\n    {\r\n        this._markers.push(marker);\r\n        this._container.appendChild(marker.element);\r\n    }\r\n\r\n    remove(marker:Marker){\r\n        const idx = this._markers.indexOf(marker);\r\n        if(idx != -1){\r\n            this._container.removeChild(marker.element);\r\n            this._markers.splice(idx, 1);\r\n        }\r\n    }\r\n\r\n    clear()\r\n    {\r\n        this._markers.length = 0;\r\n        this._container.innerHTML = \"\";\r\n    }\r\n\r\n    get element(){return this._container as HTMLElement;}\r\n    get markers(){return this._markers;}\r\n}","import { CanvasBase } from \"./CanvasBase\";\r\n\r\nexport class FrontCanvas extends CanvasBase\r\n{\r\n    private isDrawing = false;\r\n    private lastX = 0;\r\n    private lastY = 0;\r\n    private isClearMode = false;\r\n    private lineWidth = 4;\r\n    \r\n    private stuckDepth = 10;\r\n    private undoStuck:ImageData[] = [];\r\n    private redoStuck:ImageData[] = [];\r\n\r\n    // Canvas\r\n    private scaleFactor = {width:1.0, height:1.0};\r\n\r\n    constructor()\r\n    {\r\n        super();\r\n        this.element.classList.add(\"frontcanvas\");\r\n        this.initEvents();\r\n    }\r\n\r\n    private initEvents() {\r\n        this._canvas.addEventListener('pointerdown', this.startDraw);\r\n        document.addEventListener('pointermove', this.draw);\r\n        document.addEventListener('pointerup', this.endDraw);\r\n        document.addEventListener('pointerleave', this.endDraw);\r\n    }\r\n\r\n    private getPos = (e: PointerEvent | TouchEvent): { x: number, y: number } => {\r\n        const rect = this.element.getBoundingClientRect();\r\n        const position = {x:0, y:0};\r\n        if (e instanceof TouchEvent) {\r\n            position.x = e.touches[0].clientX - rect.left;\r\n            position.y = e.touches[0].clientY - rect.top;\r\n        } else {\r\n            position.x = e.clientX - rect.left;\r\n            position.y = e.clientY - rect.top;\r\n        }\r\n\r\n        position.x = position.x * this.scaleFactor.width;\r\n        position.y = position.y * this.scaleFactor.height;\r\n        \r\n        return position;\r\n    };\r\n\r\n    private startDraw = (e: PointerEvent | TouchEvent) => {\r\n        e.preventDefault();\r\n        this.isDrawing = true;\r\n        this.updateStrokeStyle();\r\n        const pos = this.getPos(e);\r\n        this.lastX = pos.x;\r\n        this.lastY = pos.y;\r\n\r\n        this.storeBuffer();\r\n    };\r\n\r\n    private draw = (e: PointerEvent | TouchEvent) => {\r\n        if (!this.isDrawing) return;\r\n        const pos = this.getPos(e);\r\n        this._ctx.beginPath();\r\n        this._ctx.moveTo(this.lastX, this.lastY);\r\n        this._ctx.lineTo(pos.x, pos.y);\r\n        this._ctx.stroke();\r\n\r\n        this._ctx.beginPath();\r\n        this._ctx.arc(pos.x, pos.y, this._ctx.lineWidth / 2, 0, Math.PI * 2);\r\n        this._ctx.fill();\r\n        this._ctx.beginPath();\r\n        this._ctx.moveTo(pos.x, pos.y);\r\n\r\n        this.lastX = pos.x;\r\n        this.lastY = pos.y;\r\n    };\r\n\r\n    private endDraw = () => {\r\n        this.isDrawing = false;\r\n    };\r\n\r\n    private updateStrokeStyle() {\r\n        this._ctx.lineWidth = this.lineWidth;\r\n        this._ctx.globalCompositeOperation = this.isClearMode ? 'destination-out' : 'source-over';\r\n        this._ctx.strokeStyle = 'white';\r\n        this._ctx.fillStyle = 'white';\r\n    }\r\n\r\n    public setLineWidth(width: number) {\r\n        this.lineWidth = width;\r\n        this.updateStrokeStyle();\r\n    }\r\n\r\n    public setEraserMode(isEraser: boolean) {\r\n        this.isClearMode = isEraser;\r\n        this.updateStrokeStyle();\r\n    }\r\n\r\n    public clearCanvas() {\r\n        this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\r\n    }\r\n\r\n    public getMask(width:number, height:number): boolean[] {\r\n        const mask:boolean[] = new Array(width * height);\r\n        \r\n        const scaledCanvas = document.createElement(\"canvas\");\r\n        scaledCanvas.width = width;\r\n        scaledCanvas.height = height;\r\n        \r\n        const scaledCtx = scaledCanvas.getContext(\"2d\");\r\n        scaledCtx?.drawImage(this._canvas, 0,0, scaledCanvas.width, scaledCanvas.height);\r\n        const data = scaledCtx?.getImageData(0, 0, scaledCanvas.width, scaledCanvas.height).data!;\r\n        \r\n        for (let i = 0; i < mask.length;i++) {\r\n            const idx = i * 4 + 3; // check alpha\r\n            mask[i] = data[idx] > 0;\r\n        }\r\n        return mask;\r\n    }\r\n\r\n    public undo()\r\n    {\r\n        if(this.undoStuck.length != 0){\r\n            this.redoStuck.push(this.getImageData());\r\n            this.setImageData(this.undoStuck.pop()!);\r\n        }\r\n    }\r\n\r\n    public redo()\r\n    {\r\n        if(this.redoStuck.length != 0)\r\n        {\r\n            this.undoStuck.push(this.getImageData());\r\n            this.setImageData(this.redoStuck.pop()!);\r\n        }\r\n    }\r\n\r\n    public reset()\r\n    {\r\n        this.redoStuck = [];\r\n        this.undoStuck = [];\r\n        this.clearCanvas();\r\n    }\r\n\r\n    private storeBuffer(){\r\n        this.undoStuck.push(this.getImageData());\r\n        this.redoStuck = [];\r\n    }\r\n}","import { Point } from \"../core/Point\";\r\nimport { Rectangle } from \"../core/Rectangle\";\r\nimport { PointerHandler } from \"../events/handler\";\r\nimport { LumimapliteCanvasPaintMode } from \"../types/LumimapliteCanvasPaintMode\";\r\nimport { BackCanvas } from \"./BackCanvas\";\r\nimport { MarkerContainer } from \"./MarkerContainer\";\r\nimport { FrontCanvas } from \"./FrontCanvas\";\r\nimport { Marker } from \"./Marker\";\r\n\r\nconst SCALE_MIN = 1.0;\r\nconst SCALE_MAX = 20.0;\r\n\r\nexport class LumimapliteCanvas {\r\n    private _element: HTMLDivElement;\r\n\r\n    private _frontCanvas: FrontCanvas;\r\n    private _backCanvas: BackCanvas;\r\n    private _markerContainer: MarkerContainer;\r\n\r\n    private _width: number = 0;\r\n    private _height: number = 0;\r\n\r\n    private _resizeObserver;\r\n    private _image: ImageBitmap | null = null;\r\n    private _scale = 1.0;\r\n    private _focusPoint = new Point(0.5,0.5);\r\n    private _imageRect:Rectangle = new Rectangle();\r\n\r\n    private _mouseDown = false;\r\n    private _downOffsetX = 0;\r\n    private _downOffsetY = 0;\r\n    private _imageRectX = 0;\r\n    private _imageRectY = 0;\r\n\r\n    private _pointerDownListeners:PointerHandler[] = [];\r\n    private _clickListeners:PointerHandler[] = [];\r\n\r\n    private paintMode: LumimapliteCanvasPaintMode = \"brush\";\r\n\r\n    constructor() {\r\n        this._element = document.createElement(\"div\");\r\n        this._element.classList.add(\"lumimaplitecanvas\");\r\n        this._backCanvas = new BackCanvas();\r\n        this._frontCanvas = new FrontCanvas();\r\n        this._markerContainer = new MarkerContainer();\r\n\r\n        this._element.appendChild(this._backCanvas.element);\r\n        this._element.appendChild(this._frontCanvas.element);\r\n        this._element.appendChild(this._markerContainer.element);\r\n\r\n        this._resizeObserver = new ResizeObserver(entries => {\r\n            for (const entry of entries) {\r\n                if (entry.target == this._element) {\r\n                    const rect = this._element.getBoundingClientRect();\r\n                    this.setSize(rect.width, rect.height);\r\n                }\r\n            }\r\n        });\r\n\r\n        this.element.addEventListener(\"pointerdown\", this.onPointerDown);\r\n        this.element.addEventListener(\"wheel\", this.onMouseWheel)\r\n    }\r\n\r\n    public setSize(width: number, height: number) {\r\n        this._width = width;\r\n        this._height = height;\r\n        this._frontCanvas.setSize(width, height);\r\n        this._backCanvas.setSize(width, height);\r\n\r\n        if(this._image){\r\n            this._imageRect = this.getScaledImageRect(this._image, this._scale, this._focusPoint);\r\n        }\r\n    }\r\n\r\n    set image(image: ImageBitmap | null) {\r\n        this._image = image;\r\n        if (this._image == null) {\r\n            this._backCanvas.clear();\r\n        }\r\n        else {\r\n            this.redraw();\r\n        }\r\n    }\r\n    get image() { return this._image; }\r\n\r\n\r\n    public clear() {\r\n        this._backCanvas.clear();\r\n        this._frontCanvas.clear();\r\n        this._markerContainer.clear();\r\n\r\n        this.resetPosition();\r\n    }\r\n\r\n    private onPointerDown = (e:PointerEvent)=>\r\n    {\r\n        this._element.setPointerCapture(e.pointerId);\r\n        this._mouseDown = true;\r\n        this._downOffsetX = e.offsetX;\r\n        this._downOffsetY = e.offsetY;\r\n        this._imageRectX = this._imageRect.x;\r\n        this._imageRectY = this._imageRect.y;\r\n\r\n        this.emitPointerDown(e);\r\n\r\n        this.element.addEventListener(\"pointermove\", this.onPointerMove);\r\n        this.element.addEventListener(\"pointerup\", this.onPointerUp);\r\n    }\r\n    private onPointerMove = (e:PointerEvent)=>\r\n    {\r\n        if(!this._mouseDown) return;\r\n\r\n        const deltaX = e.offsetX - this._downOffsetX;\r\n        const deltaY = e.offsetY - this._downOffsetY;\r\n        \r\n        this._imageRect.location = new Point(\r\n            this._imageRectX + deltaX,\r\n            this._imageRectY + deltaY);\r\n        this._imageRect.location = this.calibrateImageLocation(this._imageRect);\r\n\r\n        this.updateMarkersPosition();\r\n\r\n        this.redraw();\r\n    }\r\n    private onPointerUp = (e:PointerEvent)=>\r\n    {\r\n        this._element.releasePointerCapture(e.pointerId);\r\n        if(!this._mouseDown) return;\r\n        this._mouseDown = false;\r\n        this.redraw();\r\n\r\n        if(e.offsetX == this._downOffsetX && e.offsetY == this._downOffsetY)\r\n        {\r\n            this.emitClick(e);\r\n        }\r\n\r\n        this.element.removeEventListener(\"pointermove\", this.onPointerMove);\r\n        this.element.removeEventListener(\"pointerup\", this.onPointerUp);\r\n    }\r\n\r\n    private onMouseWheel = (e:WheelEvent)=>{\r\n        e.preventDefault();\r\n        if(e.deltaY < 0){\r\n            this.scaleAt(this.scale + 0.5, e.offsetX, e.offsetY);\r\n        }\r\n        else\r\n        {\r\n            this.scaleAt(this.scale - 0.5, e.offsetX, e.offsetY);\r\n        }\r\n    }\r\n\r\n    get scale(){return this._scale;}\r\n    set scale(scale:number){\r\n        this._scale = Math.max(SCALE_MIN, Math.min(scale, SCALE_MAX));\r\n        this._backCanvas.scale = this._scale;\r\n        this._frontCanvas.scale = this._scale;\r\n\r\n        if(this._image != null){\r\n            this._imageRect = this.getScaledImageRect(this._image, this._scale, this._focusPoint);\r\n            this._backCanvas.drawImage(this._image, this._imageRect);\r\n        }\r\n    }\r\n\r\n    /**  */\r\n    scaleAt(scale:number, offsetX:number, offsetY:number)\r\n    {\r\n        if(this._image === null) return;\r\n\r\n        const rect = this._imageRect;\r\n\r\n        // \r\n        if(offsetX < rect.x || rect.right < offsetX) return;\r\n        if(offsetY < rect.y || rect.bottom < offsetY) return;\r\n\r\n        scale = Math.max(SCALE_MIN, Math.min(scale, SCALE_MAX))\r\n        \r\n        // \r\n        if(scale === SCALE_MIN){\r\n            this.resetPosition();\r\n            this.redraw();\r\n            this.updateMarkersPosition();\r\n            return;\r\n        }\r\n\r\n        // \r\n        const pointRatio = {\r\n            x:(offsetX - rect.x) / rect.width,\r\n            y:(offsetY - rect.y) / rect.height\r\n        };\r\n\r\n        // \r\n        const newRect = this.getScaledImageRect(this._image, scale, this._focusPoint);\r\n        \r\n        // \r\n        newRect.location = new Point(\r\n            offsetX - newRect.width * pointRatio.x,\r\n            offsetY - newRect.height * pointRatio.y);\r\n\r\n        newRect.location = this.calibrateImageLocation(newRect);\r\n\r\n        this._imageRect = newRect;\r\n        this._scale = scale;\r\n        this.updateFocusPoint();\r\n\r\n        this.redraw();\r\n        this.updateMarkersPosition();\r\n    }\r\n\r\n    /**  */\r\n    redraw(){\r\n        if(this._image == null) return;\r\n        if(this._imageRect.isEmpty){\r\n            this._imageRect = this.getScaledImageRect(this._image, this._scale, this._focusPoint);\r\n        }\r\n        this._backCanvas.drawImage(this._image, this._imageRect);\r\n    }\r\n\r\n    /** */\r\n    getScaledImageRect(image:ImageBitmap, scale:number, eye:Point):Rectangle\r\n    {\r\n        const base = Math.min(this._width / image.width, this._height / image.height);\r\n\r\n        const s = base * scale;\r\n\r\n        const dw = image.width * s, dh = image.height * s;\r\n        \r\n        const canvasCenter = new Point(this._width / 2, this._height / 2);\r\n        const imageCenter = new Point(dw * eye.x, dh * eye.y);\r\n        const dx = canvasCenter.x - imageCenter.x;\r\n        const dy = canvasCenter.y - imageCenter.y;\r\n\r\n        return new Rectangle(dx, dy, dw, dh);\r\n    }\r\n\r\n    \r\n\r\n    /** XY */\r\n    calibrateImageLocation(rect:Rectangle)\r\n    {\r\n        let x = rect.x;\r\n        let y = rect.y;\r\n\r\n        if(this._width <= Math.round(rect.width))\r\n        {\r\n            if(0 < rect.x) x = 0;\r\n            else if(rect.right < this._width) x = this._width - rect.width;\r\n        }\r\n        else{\r\n            x = this._width / 2 - rect.width / 2 \r\n        }\r\n        \r\n        if(this._height <= Math.round(rect.height))\r\n        {\r\n            if(0 < rect.y) y = 0;\r\n            else if(rect.bottom < this._height) y = this._height - rect.height;\r\n        }\r\n        else{\r\n            y = this._height / 2 - rect.height / 2 \r\n        }\r\n\r\n        return new Point(x, y);\r\n    }\r\n\r\n    // \r\n    getImagePointAtClientCenter(left:number, top:number)\r\n    {\r\n        return new Point(this._width / 2 + left, this._height / 2 + top);\r\n    }\r\n\r\n    // \r\n    getFocusPoint(position:Rectangle){\r\n        const center = new Point(this._width / 2 + position.x, this._height / 2 + position.y);\r\n        return new Point(center.x / position.width, center.y / position.height);\r\n    }\r\n\r\n    // \r\n    clientCoordToImageCoord(clientX:number, clientY:number)\r\n    {\r\n        if(this._image === null) return new Point();\r\n        const point = new Point(clientX - this._imageRect.x, clientY - this._imageRect.y);\r\n        const ratio = new Point(point.x / this._imageRect.width, point.y / this._imageRect.height);\r\n        return new Point(\r\n            Math.floor(ratio.x * this._image.width), \r\n            Math.floor(ratio.y * this._image.height));\r\n    }\r\n\r\n    imageCoordToClientCoord(imageCoord:Point)\r\n    {\r\n        if(this._image === null) return new Point();\r\n        const ratio = new Point((imageCoord.x + 0.5) / this._image.width, (imageCoord.y + 0.5) / this._image.height);\r\n        const point = new Point(this._imageRect.width * ratio.x, this._imageRect.height * ratio.y);\r\n        return new Point(\r\n            this._imageRect.x + point.x, \r\n            this._imageRect.y + point.y);\r\n    }\r\n\r\n    /** */\r\n    private updateFocusPoint()\r\n    {\r\n        if(this._image == null) return;\r\n\r\n        this._focusPoint = this.getFocusPoint(this._imageRect);\r\n\r\n    }\r\n\r\n    private updateMarkersPosition()\r\n    {\r\n        for(let i = 0;i<this._markerContainer.markers.length;i++)\r\n        {\r\n            const marker = this._markerContainer.markers[i];\r\n            const clientCoord = this.imageCoordToClientCoord(marker.imageCoord);\r\n            marker.location = clientCoord;\r\n            marker.visible = !(clientCoord.x < 0 || this._width < clientCoord.x || clientCoord.y < 0 || this._height < clientCoord.y);\r\n        }\r\n    }\r\n\r\n\r\n    /**  */\r\n    resetPosition()\r\n    {\r\n        this._scale = 1.0;\r\n        this._focusPoint = new Point(0.5, 0.5);\r\n        if(this._image) this._imageRect = this.getScaledImageRect(this._image, this._scale, this._focusPoint);\r\n    }\r\n\r\n    private emitPointerDown(e:PointerEvent){\r\n        if(this._pointerDownListeners.length != 0){\r\n            for(let i=0;i<this._pointerDownListeners.length;i++) this._pointerDownListeners[i](e);\r\n        }\r\n    }\r\n    private emitClick(e:PointerEvent){\r\n        if(this._clickListeners.length != 0){\r\n            for(let i=0;i<this._clickListeners.length;i++) this._clickListeners[i](e);\r\n        }\r\n    }\r\n\r\n    pointerDown(handler:PointerHandler)\r\n    {\r\n        this._pointerDownListeners.push(handler);\r\n    }\r\n\r\n    click(handler:PointerHandler)\r\n    {\r\n        this._clickListeners.push(handler);\r\n    }\r\n\r\n    addMarker(marker:Marker){\r\n        this._markerContainer.add(marker);\r\n    }\r\n    removeMarker(marker:Marker){\r\n        this._markerContainer.remove(marker);\r\n    }\r\n\r\n    get markers() {return this._markerContainer.markers;}\r\n\r\n    get element() { return this._element as HTMLElement; }\r\n}","import { Image2d } from \"./Image2d\";\r\n\r\nconst RED = [255, 0, 0, 255]; // overflow\r\nconst BLUE = [0, 0, 255, 255]; // overflow\r\nconst VIOLET = [127, 0, 255, 255]; // underflow;\r\nconst YELLOW = [255, 255, 0.0, 255];\r\nconst ORANGE = [255, 127, 0.0, 255];\r\nconst LIGHTGREEN = [0.0, 255, 0.0, 255];\r\nconst LIGHTBLUE = [0, 255, 255, 255];\r\nconst WHITESMOKE = [245,245,245,255];\r\nconst PERME = [97, 77, 157, 255];\r\nconst TRANSPARENT = [0, 0, 0, 0];\r\n\r\nconst FLOAT32_MAX = 3.4028234663852886e+38;\r\n\r\nfunction clamp(value:number, lower:number, upper:number){\r\n    return Math.max(lower, Math.min(upper, value));\r\n}\r\n\r\nexport class BitmapUtil\r\n{\r\n    static async createImageBitmap(file:File)\r\n    {\r\n        return createImageBitmap(file);\r\n    }\r\n    static async createLMImageBitmap(imageF:Image2d, min:number, max:number){\r\n        const colorData:Uint8ClampedArray = new Uint8ClampedArray(imageF.values.length * 4);        \r\n        let rgba;\r\n        let loggedMinLimit = Math.log10(min);\r\n        let loggedMaxLimit = Math.log10(max);\r\n        let logRange = loggedMaxLimit - loggedMinLimit;\r\n\r\n        for(let i=0;i<imageF.values.length;i++){\r\n            let value = imageF.values[i];\r\n            if(value === -FLOAT32_MAX)\r\n            {\r\n                rgba = TRANSPARENT;\r\n            }\r\n            else if(value === FLOAT32_MAX)\r\n            {\r\n                rgba = TRANSPARENT;\r\n            }\r\n            else{\r\n                const clamped = clamp(value, min, max);\r\n                if(value === 0.0) value = 0.000001;\r\n                const ratio = (Math.log10(clamped)-loggedMinLimit)/logRange;\r\n                const t = 1.0 - (ratio * 2.0);\r\n                \r\n                rgba = [\r\n                    clamp(1.5 - Math.abs(2.0 * t + 1.0), 0.15, 0.85) * 255,\r\n                    clamp(1.5 - Math.abs(2.0 * t), 0.15, 0.85) * 255,\r\n                    clamp(1.5 - Math.abs(2.0 * t - 1.0), 0.15, 0.85) * 255,\r\n                    255\r\n                ]\r\n            }\r\n\r\n            const index = i*4;\r\n            colorData[index+0] = Math.round(rgba[0]);\r\n            colorData[index+1] = Math.round(rgba[1]);\r\n            colorData[index+2] = Math.round(rgba[2]);\r\n            colorData[index+3] = rgba[3]; // alpha\r\n        }\r\n        return await this.createImageBitmapWithCanvas(colorData, imageF.width, imageF.height);\r\n    }\r\n    static async createLMContrastImageBitmap(imageF:Image2d, baseLuminance:number){\r\n\r\n        const colorData:Uint8ClampedArray = new Uint8ClampedArray(imageF.values.length * 4);        \r\n        let rgba;\r\n\r\n        for(let i=0;i<imageF.values.length;i++){\r\n            let value = imageF.values[i] / baseLuminance;\r\n\r\n            if(value >= 10.0){\r\n                rgba = RED;\r\n            } \r\n            else if( value >= 3.0){\r\n                rgba = ORANGE;\r\n            }\r\n            else if( value >= 2.0){\r\n                rgba = YELLOW;\r\n            }\r\n            else if( value >= 0.5){\r\n                rgba = WHITESMOKE;\r\n            }\r\n            else if( value >= 0.3333){\r\n                rgba = LIGHTBLUE;\r\n            }\r\n            else if( value >= 0.1){\r\n                rgba = BLUE;\r\n            }\r\n            else{\r\n                rgba = PERME;\r\n            }\r\n\r\n            const index = i*4;\r\n            colorData[index+0] = rgba[0];\r\n            colorData[index+1] = rgba[1];\r\n            colorData[index+2] = rgba[2];\r\n            colorData[index+3] = rgba[3]; // alpha\r\n        }\r\n        return await this.createImageBitmapWithCanvas(colorData, imageF.width, imageF.height);\r\n    }\r\n    static async createColorOverflowImageBitmap(imageF:Image2d){\r\n        const colorData:Uint8ClampedArray = new Uint8ClampedArray(imageF.values.length * 4);        \r\n        let rgba = TRANSPARENT;\r\n\r\n        for(let i=0;i<imageF.values.length;i++){\r\n            let value = imageF.values[i];\r\n            if(value === FLOAT32_MAX)\r\n            {\r\n                rgba = RED;\r\n            }\r\n            else if(value === -FLOAT32_MAX)\r\n            {\r\n                rgba = BLUE;\r\n            }\r\n            else{\r\n                //const index = i*4;\r\n                //rgba[0] = pictureRGBAData[index+0];\r\n                //rgba[1] = pictureRGBAData[index+1];\r\n                //rgba[2] = pictureRGBAData[index+2];\r\n                //rgba[3] = pictureRGBAData[index+3];\r\n                continue;\r\n            }\r\n\r\n            const index = i*4;\r\n            colorData[index+0] = rgba[0];\r\n            colorData[index+1] = rgba[1];\r\n            colorData[index+2] = rgba[2];\r\n            colorData[index+3] = rgba[3]; // alpha\r\n        }\r\n        return await this.createImageBitmapWithCanvas(colorData, imageF.width, imageF.height);\r\n    }\r\n\r\n    private static async createImageBitmapWithCanvas(data:Uint8ClampedArray, width:number, height:number)\r\n    {\r\n        const canvas = document.createElement(\"canvas\");\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n\r\n        const ctx = canvas.getContext(\"2d\")!;\r\n        const imageData = ctx.getImageData(0,0,width,height);\r\n        imageData.data.set(data);\r\n        \r\n        return await createImageBitmap(imageData);\r\n    }\r\n\r\n    static async add(a:ImageBitmap, b:ImageBitmap, canvasWidth:number, canvasHeight:number)\r\n    {\r\n        const canvas = document.createElement(\"canvas\");\r\n        canvas.width = canvasWidth;\r\n        canvas.height = canvasHeight;\r\n\r\n        const ctx = canvas.getContext(\"2d\")!;\r\n        ctx.drawImage(a, 0, 0, canvasWidth, canvasHeight);\r\n        ctx.drawImage(b, 0, 0, canvasWidth, canvasHeight);\r\n        \r\n        const imageData = ctx.getImageData(0,0, canvasWidth, canvasHeight);\r\n\r\n        return await createImageBitmap(imageData);\r\n    }\r\n}","export class Settings {\r\n    lm = {\r\n        min:0.00001,\r\n        max:100000\r\n    };\r\n    lmc = {\r\n        baseLuminance:200,\r\n    };\r\n};","import { ImageTypes } from \"./types/ImageTypes\";\r\n\r\nexport const Limits = {FLOAT32_MAX: 3.4028234663852886e+38};\r\nexport const ImageOrder = [\"picture\", \"lm\", \"lmc\", \"cof\"] as ImageTypes[];\r\nexport const InitialImageType:ImageTypes = \"lm\";","import { unzipSync } from 'fflate';\r\nimport { Image2d } from \"./core/Image2d\";\r\nimport { Marker } from \"./controls/Marker\";\r\nimport { Scalebar } from \"./controls/Scalebar\";\r\nimport { ImageTypes } from \"./types/ImageTypes\";\r\nimport { ImageSelector } from \"./controls/ImageSelector\";\r\nimport { PFMData, PFMLoader } from './core/PFMLoader';\r\nimport { LumimapliteCanvas } from './controls/LumimapliteCanvas';\r\nimport { BitmapUtil } from './core/BitmapUtil';\r\nimport { Point } from './core/Point';\r\nimport { Settings } from './core/Settings';\r\nimport { ImageOrder, InitialImageType, Limits } from './constants';\r\n\r\n\r\nexport class LumimapLite\r\n{\r\n    // Settings\r\n    \r\n    // Data\r\n    private _src:File | null = null;\r\n    private _lumiData:Image2d | null = null;\r\n    private _imageDatas:Map<ImageTypes, ImageBitmap> = new Map();\r\n    private _baseLuminance = 0;\r\n    private _settings = new Settings();\r\n    \r\n    // \r\n    private _container;\r\n\r\n    // Controls\r\n    private _scalebar:Scalebar = new Scalebar();\r\n    private _lumimapCanvas:LumimapliteCanvas;\r\n    private _imageSelector:ImageSelector;\r\n    private _resizeObserver;\r\n    \r\n    constructor(container:HTMLDivElement)\r\n    {\r\n        if(container == null) throw new Error(\"Invalid argument.\");\r\n        this._container = container;\r\n\r\n        this._scalebar = new Scalebar();\r\n        this._scalebar.visible = false;\r\n        this._imageSelector = new ImageSelector(ImageOrder);\r\n        this._imageSelector.visible = false;\r\n        this._imageSelector.onChanged(this.onImageSelectorChanged);\r\n        this._lumimapCanvas = new LumimapliteCanvas();\r\n        //this._lumimapCanvas.pointerDown(this.onCanvasPointerDown);\r\n        this._lumimapCanvas.click(this.onCanvasClick);\r\n\r\n        this._resizeObserver = new ResizeObserver(entries => {\r\n            for (const entry of entries) {\r\n                if(entry.target == this._lumimapCanvas.element)\r\n                {\r\n                    this.onControlResized();\r\n                }\r\n            }\r\n        });\r\n\r\n    }\r\n\r\n    // \r\n    init(){\r\n        this.reset();\r\n        this._container.appendChild(this._lumimapCanvas.element);\r\n        this._container.appendChild(this._imageSelector.element);\r\n        this._container.appendChild(this._scalebar.element);\r\n\r\n        this.onControlResized();\r\n    }\r\n\r\n    // \r\n    // JpgPFM\r\n    // @param file jpeg or pfm\r\n    async loadAsync(file:File)\r\n    {\r\n        this.reset();\r\n\r\n        try\r\n        {\r\n            let pfmData:PFMData;\r\n            if(file.type == \"image/x-portable-floatmap\" || file.type == \"image/x-pfm\" || file.name.includes(\".pfm\")){\r\n                pfmData = PFMLoader.Load(new Uint8Array(await file.arrayBuffer()));\r\n            }\r\n            else if(file.type == \"image/jpeg\"){\r\n                pfmData = await this.fetchData(file);\r\n            }\r\n            else{\r\n                throw new Error(\"unsupported file type.\");\r\n            }\r\n            \r\n            this._lumiData = new Image2d(pfmData.grayscale!, pfmData.width, pfmData.height);\r\n            await this.initializeImageBitmaps(file, this._lumiData!);\r\n\r\n            this.controlVisible = true;\r\n\r\n            this.changeImage(InitialImageType);\r\n        }\r\n        catch(ex)\r\n        {\r\n            // error here\r\n            if(ex instanceof Error)\r\n            {\r\n                console.error(ex.message);\r\n            }\r\n            else\r\n            {\r\n                console.error(ex);\r\n            }\r\n            \r\n        }\r\n    }\r\n\r\n    private async initializeImageBitmaps(jpg:File, imageF:Image2d)\r\n    {\r\n        const pictureBitmap = await BitmapUtil.createImageBitmap(jpg);\r\n        this._imageDatas.set(\"picture\", pictureBitmap);\r\n\r\n        await this.updateLmImageBitmap(imageF, pictureBitmap, this._settings.lm.min, this._settings.lm.max);\r\n        await this.updateLmcImageBitmap(imageF, this._settings.lmc.baseLuminance);\r\n        await this.updateCofImageBitmap(imageF, pictureBitmap);\r\n    }\r\n\r\n    // \r\n    private async fetchData(jpeg:File)\r\n    {\r\n        const url = 'https://ik1-127-70116.vs.sakura.ne.jp/markAnomaly';\r\n        const formData = new FormData();\r\n        formData.append(\"file\", jpeg);\r\n\r\n        return await fetch(url, {\r\n            method: \"POST\",\r\n            //body: JSON.stringify({ file1: file }),\r\n            body: formData\r\n        })\r\n        .then(response =>{\r\n            if (!response.ok)  throw new Error(`HTTP error! Status: ${response.status}`);\r\n            return response.arrayBuffer();\r\n        })\r\n        .then(buffer => unzipSync(new Uint8Array(buffer)))\r\n        .then(zip =>{\r\n            for (const [name, data] of Object.entries(zip) as [string, Uint8Array][]) {\r\n                if(name.includes(\".pfm\"))\r\n                {\r\n                    return PFMLoader.Load(data);\r\n                }\r\n            }\r\n            throw new Error('Could not found PFM File');\r\n        })\r\n        .catch(e=>{\r\n            console.log(e);\r\n            throw new Error('Failed to fetch file');\r\n        });\r\n    }\r\n\r\n    // \r\n    reset()\r\n    {\r\n        this._lumimapCanvas.clear();\r\n        this._imageDatas.clear();\r\n        this._settings = new Settings();\r\n        this.controlVisible = false;\r\n    }\r\n\r\n    private set controlVisible(tf:boolean)\r\n    {\r\n        this._imageSelector.visible = tf;\r\n        this._scalebar.visible = tf;\r\n    }\r\n\r\n    private onControlResized()\r\n    {\r\n        const rect = this._container.getBoundingClientRect();\r\n        this._lumimapCanvas.setSize(rect.width, rect.height);\r\n    }\r\n\r\n    private onImageSelectorChanged=(e:Event)=>\r\n    {\r\n        const imageType = this._imageSelector.selectedImageType;\r\n        if(this._imageDatas.has(imageType))\r\n        {\r\n            this.changeImage(imageType);\r\n        }\r\n    }\r\n    private onCanvasPointerDown=(e:PointerEvent)=>\r\n    {\r\n        if(this._lumiData === null) return;\r\n    }\r\n    \r\n    private onCanvasClick=(e:PointerEvent)=>\r\n    {\r\n        if(e.button != 0) return;\r\n        if(this._lumiData === null) return;\r\n\r\n        const ic = this._lumimapCanvas.clientCoordToImageCoord(e.offsetX, e.offsetY);\r\n        if(ic.x < 0 || this._lumiData.width < ic.x || ic.y < 0 || this._lumiData.height < ic.y) return;\r\n\r\n        const marker = new Marker();\r\n        marker.location = new Point(e.offsetX, e.offsetY);\r\n        marker.imageCoord = ic;\r\n        this.setMarkerTips(marker);\r\n        marker.onClick(this.onMarkerClick);\r\n        this._lumimapCanvas.addMarker(marker);\r\n    }\r\n\r\n    private onMarkerClick=(sender:Marker, e:PointerEvent)=>{\r\n        if(e.button != 0) return;\r\n        sender.offClick(this.onMarkerClick);\r\n        this._lumimapCanvas.removeMarker(sender);\r\n    }\r\n\r\n    private changeImage(imageType:ImageTypes){\r\n        this._imageSelector.selectedImageType = imageType;\r\n        this._lumimapCanvas.image = this._imageDatas.get(imageType)!;\r\n\r\n        switch(imageType)\r\n        {\r\n            case \"picture\":\r\n            case \"cof\":\r\n                this._scalebar.visible = false;\r\n                break;\r\n            default:\r\n                this._scalebar.visible = true;\r\n                switch(imageType)\r\n                {\r\n                    case \"lm\":\r\n                        this._scalebar.drawLmScale(this._settings.lm.min, this._settings.lm.max);\r\n                        break;\r\n                    case \"lmc\":\r\n\r\n                        this._scalebar.drawLmcScale();\r\n                        break;\r\n                    //case \"cof\":\r\n                    //    this._scalebar.visible = false;\r\n                        break;\r\n                }\r\n            break;\r\n        }\r\n\r\n        this.updateAllMarkerTips();\r\n    }\r\n\r\n    private updateAllMarkerTips()\r\n    {\r\n        for(let i = 0;i<this._lumimapCanvas.markers.length;i++)\r\n        {\r\n            const marker = this._lumimapCanvas.markers[i];\r\n            this.setMarkerTips(marker);\r\n        }\r\n    }\r\n\r\n    private setMarkerTips(marker:Marker)\r\n    {\r\n        switch(this._imageSelector.selectedImageType)\r\n        {\r\n            case \"lm\":\r\n                this.setLmTips(marker);\r\n                break;\r\n            case \"lmc\":\r\n                this.setLmcTips(marker);\r\n                break;\r\n            case \"cof\":\r\n            default:\r\n                this.hideMarkerTips(marker);\r\n                break;   \r\n        }\r\n    }\r\n\r\n    private setLmTips(marker:Marker)\r\n    {\r\n        const val = this._lumiData!.getValue(marker.imageCoord.x, marker.imageCoord.y);\r\n        let text = val.toFixed(2);\r\n        if(Limits.FLOAT32_MAX <= val) text = \"+overflow\";\r\n        else if(val <= -Limits.FLOAT32_MAX) text = \"-overflow\";\r\n        marker.text = text;\r\n        marker.tipsVisible = true;\r\n    }\r\n    private setLmcTips(marker:Marker)\r\n    {\r\n        const val = this._lumiData!.getValue(marker.imageCoord.x, marker.imageCoord.y);\r\n        let text = (val / this._settings.lmc.baseLuminance).toFixed(2);\r\n        if(Limits.FLOAT32_MAX <= val) text = \"+overflow\";\r\n        else if(val <= -Limits.FLOAT32_MAX) text = \"-overflow\";\r\n        marker.text = text;\r\n        marker.tipsVisible = true;\r\n    }\r\n    private hideMarkerTips(marker:Marker)\r\n    {\r\n        marker.tipsVisible = false;\r\n    }\r\n\r\n    private async updateLmImageBitmap(imageF:Image2d, pictBitmap:ImageBitmap, min:number, max:number)\r\n    {\r\n        const type:ImageTypes = \"lm\";\r\n        const lmBitmap = await BitmapUtil.createLMImageBitmap(imageF, min, max);\r\n\r\n        // \r\n        const bitmap = await BitmapUtil.add(pictBitmap, lmBitmap, lmBitmap.width, lmBitmap.height);\r\n\r\n        // BitmapDispose\r\n        const old = this._imageDatas.get(type);\r\n        if(old) old.close();\r\n        lmBitmap.close();\r\n\r\n        this._imageDatas.set(type, bitmap);\r\n    }\r\n    private async updateLmcImageBitmap(imageF:Image2d, baseLuminance:number)\n    {\n        const type:ImageTypes = \"lmc\";\n        const bitmap = await BitmapUtil.createLMContrastImageBitmap(imageF, baseLuminance);\n\n        // BitmapDispose\n        const old = this._imageDatas.get(type);\n        if(old) old.close();\n\n        this._imageDatas.set(type, bitmap);\n    }\n\n    get lmcBaseLuminance(){\n        return this._settings.lmc.baseLuminance;\n    }\n\n    async setLmcBaseLuminance(baseLuminance:number){\n        if(!Number.isFinite(baseLuminance) || baseLuminance <= 0) return;\n        this._settings.lmc.baseLuminance = baseLuminance;\n        if(this._lumiData){\n            await this.updateLmcImageBitmap(this._lumiData, this._settings.lmc.baseLuminance);\n            if(this._imageSelector.selectedImageType === \"lmc\"){\n                this.changeImage(\"lmc\");\n            }\n            else{\n                this.updateAllMarkerTips();\n            }\n        }\n    }\n\r\n    private async updateCofImageBitmap(imageF:Image2d, pictBitmap:ImageBitmap)\r\n    {\r\n        const type:ImageTypes = \"cof\";\r\n        const cofBitmap = await BitmapUtil.createColorOverflowImageBitmap(imageF);\r\n        \r\n        // \r\n        const bitmap = await BitmapUtil.add(pictBitmap, cofBitmap, cofBitmap.width, cofBitmap.height);\r\n\r\n        // BitmapDispose\r\n        const old = this._imageDatas.get(type);\r\n        if(old) old.close();\r\n\r\n        this._imageDatas.set(type, bitmap);        \r\n    }\r\n}\r\n","import { unzipSync } from 'fflate';\r\nimport { MaskCanvas } from './MaskCanvas';\r\nimport { PFMData, PFMLoader } from './core/PFMLoader';\r\nimport { ImageDataCalculator } from './core/ImageDataCalculator';\r\nimport { LumimapLite } from './LumimapLite';\r\n\r\n\r\n// \r\n// 1.(input[type=file])\r\n// 2.POSTPFMZip\r\n// 3.PFM\r\n// 4.PFMImgMarkableCanvas\r\n\r\n\r\ndocument.addEventListener('DOMContentLoaded', function () {\r\n    const box = document.querySelector(\".paintbox\") as HTMLDivElement;\r\n    const canvasContainer = document.querySelector(\".lumimaplite\") as HTMLDivElement;\r\n\r\n    const fileInput = document.querySelector(\"#fileinput\") as HTMLInputElement;\r\n\r\n    //const paintableCanvas = new MaskCanvas(canvasContainer);\r\n    //const canvasRect = canvas.getBoundingClientRect();\r\n    //paintableCanvas.setCanvasSize(canvasRect.width, canvasRect.height);\r\n\r\n    // const slider = document.getElementById('lineWidthSlider') as HTMLInputElement;\r\n    // const valueLabel = document.getElementById('lineWidthValue') as HTMLLabelElement;\r\n    // const chkEraser = document.getElementById(\"useEraser\") as HTMLInputElement;\r\n    const baseLuminanceInput = document.getElementById(\"baseLuminanceInput\") as HTMLInputElement | null;\r\n\r\n    // const pResult = document.getElementById(\"result\") as HTMLInputElement; \r\n\r\n    const lumimap = new LumimapLite(canvasContainer);\r\n    lumimap.init();\r\n    if (baseLuminanceInput) {\r\n        baseLuminanceInput.value = lumimap.lmcBaseLuminance.toString();\r\n    }\r\n\r\n    let pfmData: PFMData;\r\n    let luminanceFile: Blob;\r\n    let luminanceFileURL: string = \"\";\r\n\r\n    // function updateLineWidth()\r\n    // {\r\n    //     const value = slider.value;\r\n    //     //paintableCanvas.setLineWidth(Number(value));\r\n    //     valueLabel.innerHTML = value;\r\n    // }\r\n\r\n    function updateEraseMode() {\r\n        //paintableCanvas.setEraserMode(chkEraser.checked);\r\n    }\r\n\r\n    function savePFM(arrayBuffer: Uint8Array<ArrayBufferLike>, filename = \"image.pfm\") {\r\n        // ArrayBuffer  Blob\r\n        let data = new Uint8Array(arrayBuffer);\r\n        const blob = new Blob([data], { type: \"application/octet-stream\" });\r\n\r\n        // \r\n        const url = URL.createObjectURL(blob);\r\n        const a = document.createElement(\"a\");\r\n        a.href = url;\r\n        a.download = filename;\r\n        document.body.appendChild(a);\r\n        a.click();\r\n\r\n        // \r\n        setTimeout(() => {\r\n            document.body.removeChild(a);\r\n            URL.revokeObjectURL(url);\r\n        }, 0);\r\n    }\r\n    function saveJpeg(arrayBuffer: ArrayBuffer, filename = \"image.jpg\") {\r\n        // ArrayBuffer  Blob\r\n        const blob = new Blob([arrayBuffer], { type: \"image/jpeg\" });\r\n\r\n        // \r\n        const url = URL.createObjectURL(blob);\r\n        const a = document.createElement(\"a\");\r\n        a.href = url;\r\n        a.download = filename;\r\n        document.body.appendChild(a);\r\n        a.click();\r\n\r\n        // \r\n        setTimeout(() => {\r\n            document.body.removeChild(a);\r\n            URL.revokeObjectURL(url);\r\n        }, 0);\r\n    }\r\n    function createColorArray(pfmData: PFMData, minLimit: number, maxLimit: number) {\r\n        function clamp(value: number, lower: number, upper: number) {\r\n            return Math.max(lower, Math.min(upper, value));\r\n        }\r\n        const srcData = pfmData.grayscale!;\r\n        const colorData: Uint8ClampedArray = new Uint8ClampedArray(pfmData.width * pfmData.height * 4);\r\n\r\n        const RED = [255, 0, 0, 255]; // overflow\r\n        const VIOLET = [127, 0, 255, 255]; // underflow;\r\n        const TRANSPARENT = [0, 0, 0, 0];\r\n        const FLOAT32_MAX = 3.4028234663852886e+38;\r\n        let rgba;\r\n        let loggedMinLimit = Math.log10(minLimit);\r\n        let loggedMaxLimit = Math.log10(maxLimit);\r\n        let logRange = loggedMaxLimit - loggedMinLimit;\r\n\r\n        for (let i = 0; i < srcData.length; i++) {\r\n            let value = srcData[i];\r\n            if (value === -FLOAT32_MAX) {\r\n                rgba = TRANSPARENT;\r\n            }\r\n            else if (value === FLOAT32_MAX) {\r\n                rgba = TRANSPARENT;\r\n            }\r\n            else {\r\n                const clamped = clamp(value, minLimit, maxLimit);\r\n                if (value === 0.0) value = 0.000001;\r\n                const ratio = (Math.log10(clamped) - loggedMinLimit) / logRange;\r\n                const t = 1.0 - (ratio * 2.0);\r\n\r\n                rgba = [\r\n                    clamp(1.5 - Math.abs(2.0 * t + 1.0), 0.15, 0.85) * 255,\r\n                    clamp(1.5 - Math.abs(2.0 * t), 0.15, 0.85) * 255,\r\n                    clamp(1.5 - Math.abs(2.0 * t - 1.0), 0.15, 0.85) * 255,\r\n                    255\r\n                ]\r\n            }\r\n\r\n            const index = i * 4;\r\n            colorData[index + 0] = Math.round(rgba[0]);\r\n            colorData[index + 1] = Math.round(rgba[1]);\r\n            colorData[index + 2] = Math.round(rgba[2]);\r\n            colorData[index + 3] = rgba[3]; // alpha\r\n        }\r\n        return colorData;\r\n    }\r\n\r\n    // slider.addEventListener('input', updateLineWidth);\r\n    // chkEraser.addEventListener(\"change\", updateEraseMode);\r\n    if (baseLuminanceInput) {\r\n        const updateBaseLuminance = () => {\r\n            const value = Number(baseLuminanceInput.value);\r\n            if (Number.isFinite(value) && 0 < value) {\r\n                void lumimap.setLmcBaseLuminance(value);\r\n            }\r\n            else {\r\n                baseLuminanceInput.value = lumimap.lmcBaseLuminance.toString();\r\n            }\r\n        };\r\n        baseLuminanceInput.addEventListener('change', updateBaseLuminance);\r\n        baseLuminanceInput.addEventListener('blur', updateBaseLuminance);\r\n    }\r\n\r\n    async function fetchPFM(file: File) {\r\n        const url = 'https://ik1-127-70116.vs.sakura.ne.jp/markAnomaly';\r\n\r\n        const formData = new FormData();\r\n        formData.append(\"file\", file);\r\n\r\n        return await fetch(url, {\r\n            method: \"POST\",\r\n            //body: JSON.stringify({ file1: file }),\r\n            body: formData\r\n        })\r\n            .then(res => {\r\n                return res.arrayBuffer();\r\n            })\r\n            .then(buffer => {\r\n                const zip = unzipSync(new Uint8Array(buffer));\r\n                console.log(Object.entries(zip));\r\n                for (const [name, data] of Object.entries(zip) as [string, Uint8Array][]) {\r\n                    console.log(name);\r\n                    if (name.includes(\".pfm\")) {\r\n                        savePFM(data, name);\r\n                        return PFMLoader.Load(data);\r\n                    }\r\n                    //else if(name.includes(\".jpg\"))\r\n                    //{\r\n                    //console.log(name);\r\n                    //    saveJpeg(data, name);\r\n                    //}\r\n                    //else if(name.includes(\"_Luminance.jpg\"))\r\n                    //{\r\n                    //    luminanceFile = new Blob([data], { type: 'image/jpeg' });\r\n                    //    if(luminanceFileURL !== \"\") URL.revokeObjectURL(luminanceFileURL);\r\n                    //    luminanceFileURL = URL.createObjectURL(luminanceFile);                \r\n                    //    backimage.src = luminanceFileURL;\r\n                    //}\r\n                    //console.log(name);\r\n                }\r\n                throw new Error('PFM File Not Found');\r\n            })\r\n            .catch(e => {\r\n                throw new Error('Failed to fetch file');\r\n            });\r\n\r\n\r\n    }\r\n\r\n    fileInput.addEventListener(\"change\", async () => {\r\n        // API URL\r\n        const file = fileInput.files![0];\r\n        if (file) {\r\n            await lumimap.loadAsync(file);\r\n            if (baseLuminanceInput) {\r\n                baseLuminanceInput.value = lumimap.lmcBaseLuminance.toString();\r\n            }\r\n            //const pfmData = await fetchPFM(file );\r\n            //const pfmData = PFMLoader.Load(new Uint8Array(await file.arrayBuffer()));\r\n            //const data = createColorArray(pfmData, 0.00001, 10000);\r\n            //paintableCanvas.setImageFromArrayBuffer(data, pfmData.width, pfmData.height)\r\n        }\r\n    });\r\n\r\n    const calcButton = document.querySelector(\"#calc\") as HTMLInputElement;\r\n    calcButton.addEventListener(\"click\", () => {\r\n        /*\r\n        if(pfmData === null) return;\r\n        const mask = markupCanvas.getMask(pfmData.width, pfmData.height);\r\n\r\n        if(pfmData.data instanceof Float32Array){\r\n            const result = ImageDataCalculator.calcAverage(pfmData.data, mask);\r\n            const min = result.min?.toFixed(2);\r\n            const max = result.max?.toFixed(2);\r\n            const average = result.average?.toFixed(2);\r\n            pResult.innerText = \"MIN:\" + min + \" MAX:\" + max + \" AVERAGE:\"+average; \r\n        }\r\n        */\r\n    });\r\n\r\n    const resetButton = document.querySelector(\"#reset\") as HTMLInputElement;\r\n    resetButton.addEventListener(\"click\", () => {\r\n        //paintableCanvas.clearCanvas();\r\n    });\r\n\r\n});\r\n"],"names":["u8","u16","i32","fleb","fdeb","clim","freb","eb","start","b","r","j","_a","fl","revfl","_b","fd","rev","i","x","hMap","cd","mb","s","l","le","co","rvb","sv","r_1","v","m","flt","fdt","flrm","fdrm","max","bits","d","p","o","bits16","shft","slc","ec","err","ind","msg","nt","e","inflt","dat","st","buf","dict","sl","dl","noBuf","resize","noSt","cbuf","bl","nbuf","final","pos","bt","lm","dm","lbt","dbt","tbts","type","hLit","hcLen","tl","ldt","clt","clb","clbmsk","clm","c","n","lt","dt","t","lms","dms","lpos","sym","add","dsym","end","shift","dend","et","b2","b4","b8","inflateSync","data","opts","td","tds","dutf8","strFromU8","latin1","slzh","zh","z","fnl","fn","es","bs","z64e","sc","su","off","unzipSync","files","ze","c_2","no","PFMLoader","bytes","textDecoder","offset","readLine","line","format","isColor","sizeLine","widthStr","heightStr","width","height","scaleLine","scaleEndianness","scale","littleEndian","numChannels","numPixels","dataView","floatData","pfmData","g","y","src_y","src_i","dst_i","values","Image2d","Point","Marker","elem","finder","tips","point","text","location","tf","handler","idx","imageTypeToName","clamp","value","min","CANVAS_WIDTH","CANVAS_HEIGHT","SCALEBAR_WIDTH","verticalMargin","PIXEL_OFFSET","Scalebar","scalebar","canvas","ctx","scalebarWidth","scalebarHeight","logMin","step","ticks","interval","tickWidth","fixed","labels","colors","label","points","upper","lower","range","ratio","getY","absY","colorNames","nextY","areaHeight","ImageSelector","imageTypes","select","option","h","Rectangle","CanvasBase","imageData","image","rect","bitmap","BackCanvas","MarkerContainer","container","marker","FrontCanvas","position","isEraser","mask","scaledCanvas","scaledCtx","SCALE_MIN","SCALE_MAX","LumimapliteCanvas","deltaX","deltaY","entries","entry","offsetX","offsetY","pointRatio","newRect","eye","dw","dh","canvasCenter","imageCenter","dx","dy","left","top","center","clientX","clientY","imageCoord","clientCoord","RED","BLUE","YELLOW","ORANGE","LIGHTBLUE","WHITESMOKE","PERME","TRANSPARENT","FLOAT32_MAX","BitmapUtil","file","imageF","colorData","rgba","loggedMinLimit","logRange","clamped","index","baseLuminance","a","canvasWidth","canvasHeight","Settings","Limits","ImageOrder","InitialImageType","LumimapLite","imageType","ic","sender","ex","jpg","pictureBitmap","jpeg","url","formData","response","buffer","zip","name","val","pictBitmap","lmBitmap","old","cofBitmap","canvasContainer","fileInput","baseLuminanceInput","lumimap","updateBaseLuminance"],"mappings":"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","x_google_ignoreList":[0]}